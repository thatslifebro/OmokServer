// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OmokPacket.proto

#include "OmokPacket.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace OmokPacket {
PROTOBUF_CONSTEXPR ReqLogin::ReqLogin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pw_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqLoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqLoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqLoginDefaultTypeInternal() {}
  union {
    ReqLogin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqLoginDefaultTypeInternal _ReqLogin_default_instance_;
PROTOBUF_CONSTEXPR ResLogin::ResLogin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResLoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResLoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResLoginDefaultTypeInternal() {}
  union {
    ResLogin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResLoginDefaultTypeInternal _ResLogin_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomEnter::ReqRoomEnter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roomid_)*/0} {}
struct ReqRoomEnterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomEnterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomEnterDefaultTypeInternal() {}
  union {
    ReqRoomEnter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomEnterDefaultTypeInternal _ReqRoomEnter_default_instance_;
PROTOBUF_CONSTEXPR ResRoomEnter::ResRoomEnter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomEnterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomEnterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomEnterDefaultTypeInternal() {}
  union {
    ResRoomEnter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomEnterDefaultTypeInternal _ResRoomEnter_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomUserList::NtfRoomUserList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userid_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NtfRoomUserListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomUserListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomUserListDefaultTypeInternal() {}
  union {
    NtfRoomUserList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomUserListDefaultTypeInternal _NtfRoomUserList_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomNewUser::NtfRoomNewUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfRoomNewUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomNewUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomNewUserDefaultTypeInternal() {}
  union {
    NtfRoomNewUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomNewUserDefaultTypeInternal _NtfRoomNewUser_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomLeave::ReqRoomLeave(
    ::_pbi::ConstantInitialized) {}
struct ReqRoomLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomLeaveDefaultTypeInternal() {}
  union {
    ReqRoomLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomLeaveDefaultTypeInternal _ReqRoomLeave_default_instance_;
PROTOBUF_CONSTEXPR ResRoomLeave::ResRoomLeave(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomLeaveDefaultTypeInternal() {}
  union {
    ResRoomLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomLeaveDefaultTypeInternal _ResRoomLeave_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomLeaveUser::NtfRoomLeaveUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfRoomLeaveUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomLeaveUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomLeaveUserDefaultTypeInternal() {}
  union {
    NtfRoomLeaveUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomLeaveUserDefaultTypeInternal _NtfRoomLeaveUser_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomChat::ReqRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomChatDefaultTypeInternal() {}
  union {
    ReqRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomChatDefaultTypeInternal _ReqRoomChat_default_instance_;
PROTOBUF_CONSTEXPR ResRoomChat::ResRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomChatDefaultTypeInternal() {}
  union {
    ResRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomChatDefaultTypeInternal _ResRoomChat_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomChat::NtfRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomChatDefaultTypeInternal() {}
  union {
    NtfRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomChatDefaultTypeInternal _NtfRoomChat_default_instance_;
PROTOBUF_CONSTEXPR ReqMatch::ReqMatch(
    ::_pbi::ConstantInitialized) {}
struct ReqMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqMatchDefaultTypeInternal() {}
  union {
    ReqMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqMatchDefaultTypeInternal _ReqMatch_default_instance_;
PROTOBUF_CONSTEXPR ResMatch::ResMatch(
    ::_pbi::ConstantInitialized) {}
struct ResMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResMatchDefaultTypeInternal() {}
  union {
    ResMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResMatchDefaultTypeInternal _ResMatch_default_instance_;
PROTOBUF_CONSTEXPR NtfMatched::NtfMatched(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfMatchedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfMatchedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfMatchedDefaultTypeInternal() {}
  union {
    NtfMatched _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfMatchedDefaultTypeInternal _NtfMatched_default_instance_;
PROTOBUF_CONSTEXPR ReqReadyOmok::ReqReadyOmok(
    ::_pbi::ConstantInitialized) {}
struct ReqReadyOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqReadyOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqReadyOmokDefaultTypeInternal() {}
  union {
    ReqReadyOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqReadyOmokDefaultTypeInternal _ReqReadyOmok_default_instance_;
PROTOBUF_CONSTEXPR ResReadyOmok::ResReadyOmok(
    ::_pbi::ConstantInitialized) {}
struct ResReadyOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResReadyOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResReadyOmokDefaultTypeInternal() {}
  union {
    ResReadyOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResReadyOmokDefaultTypeInternal _ResReadyOmok_default_instance_;
PROTOBUF_CONSTEXPR NtfStartOmok::NtfStartOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.black_)*/false} {}
struct NtfStartOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfStartOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfStartOmokDefaultTypeInternal() {}
  union {
    NtfStartOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfStartOmokDefaultTypeInternal _NtfStartOmok_default_instance_;
PROTOBUF_CONSTEXPR ReqPutMok::ReqPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct ReqPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqPutMokDefaultTypeInternal() {}
  union {
    ReqPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqPutMokDefaultTypeInternal _ReqPutMok_default_instance_;
PROTOBUF_CONSTEXPR ResPutMok::ResPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResPutMokDefaultTypeInternal() {}
  union {
    ResPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResPutMokDefaultTypeInternal _ResPutMok_default_instance_;
PROTOBUF_CONSTEXPR NtfPutMok::NtfPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct NtfPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfPutMokDefaultTypeInternal() {}
  union {
    NtfPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfPutMokDefaultTypeInternal _NtfPutMok_default_instance_;
PROTOBUF_CONSTEXPR NtfEndOmok::NtfEndOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.win_)*/false} {}
struct NtfEndOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfEndOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfEndOmokDefaultTypeInternal() {}
  union {
    NtfEndOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfEndOmokDefaultTypeInternal _NtfEndOmok_default_instance_;
}  // namespace OmokPacket
static ::_pb::Metadata file_level_metadata_OmokPacket_2eproto[22];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_OmokPacket_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_OmokPacket_2eproto = nullptr;

const uint32_t TableStruct_OmokPacket_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_.pw_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _impl_.roomid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_.result_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomUserList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomUserList, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _impl_.userid_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _impl_.userid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_.chat_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_.chat_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_.chat_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatched, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatched, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatched, _impl_.userid_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqReadyOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResReadyOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_.black_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _impl_.win_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::OmokPacket::ReqLogin)},
  { 10, 17, -1, sizeof(::OmokPacket::ResLogin)},
  { 18, 25, -1, sizeof(::OmokPacket::ReqRoomEnter)},
  { 26, 33, -1, sizeof(::OmokPacket::ResRoomEnter)},
  { 34, -1, -1, sizeof(::OmokPacket::NtfRoomUserList)},
  { 41, 48, -1, sizeof(::OmokPacket::NtfRoomNewUser)},
  { 49, -1, -1, sizeof(::OmokPacket::ReqRoomLeave)},
  { 55, 62, -1, sizeof(::OmokPacket::ResRoomLeave)},
  { 63, 70, -1, sizeof(::OmokPacket::NtfRoomLeaveUser)},
  { 71, 78, -1, sizeof(::OmokPacket::ReqRoomChat)},
  { 79, 87, -1, sizeof(::OmokPacket::ResRoomChat)},
  { 89, 97, -1, sizeof(::OmokPacket::NtfRoomChat)},
  { 99, -1, -1, sizeof(::OmokPacket::ReqMatch)},
  { 105, -1, -1, sizeof(::OmokPacket::ResMatch)},
  { 111, 118, -1, sizeof(::OmokPacket::NtfMatched)},
  { 119, -1, -1, sizeof(::OmokPacket::ReqReadyOmok)},
  { 125, -1, -1, sizeof(::OmokPacket::ResReadyOmok)},
  { 131, 138, -1, sizeof(::OmokPacket::NtfStartOmok)},
  { 139, 147, -1, sizeof(::OmokPacket::ReqPutMok)},
  { 149, 156, -1, sizeof(::OmokPacket::ResPutMok)},
  { 157, 165, -1, sizeof(::OmokPacket::NtfPutMok)},
  { 167, 174, -1, sizeof(::OmokPacket::NtfEndOmok)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::OmokPacket::_ReqLogin_default_instance_._instance,
  &::OmokPacket::_ResLogin_default_instance_._instance,
  &::OmokPacket::_ReqRoomEnter_default_instance_._instance,
  &::OmokPacket::_ResRoomEnter_default_instance_._instance,
  &::OmokPacket::_NtfRoomUserList_default_instance_._instance,
  &::OmokPacket::_NtfRoomNewUser_default_instance_._instance,
  &::OmokPacket::_ReqRoomLeave_default_instance_._instance,
  &::OmokPacket::_ResRoomLeave_default_instance_._instance,
  &::OmokPacket::_NtfRoomLeaveUser_default_instance_._instance,
  &::OmokPacket::_ReqRoomChat_default_instance_._instance,
  &::OmokPacket::_ResRoomChat_default_instance_._instance,
  &::OmokPacket::_NtfRoomChat_default_instance_._instance,
  &::OmokPacket::_ReqMatch_default_instance_._instance,
  &::OmokPacket::_ResMatch_default_instance_._instance,
  &::OmokPacket::_NtfMatched_default_instance_._instance,
  &::OmokPacket::_ReqReadyOmok_default_instance_._instance,
  &::OmokPacket::_ResReadyOmok_default_instance_._instance,
  &::OmokPacket::_NtfStartOmok_default_instance_._instance,
  &::OmokPacket::_ReqPutMok_default_instance_._instance,
  &::OmokPacket::_ResPutMok_default_instance_._instance,
  &::OmokPacket::_NtfPutMok_default_instance_._instance,
  &::OmokPacket::_NtfEndOmok_default_instance_._instance,
};

const char descriptor_table_protodef_OmokPacket_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020OmokPacket.proto\022\nOmokPacket\"B\n\010ReqLog"
  "in\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\017\n\002pw\030\002 \001(\tH\001\210\001\001"
  "B\t\n\007_userIdB\005\n\003_pw\"*\n\010ResLogin\022\023\n\006result"
  "\030\001 \001(\005H\000\210\001\001B\t\n\007_result\".\n\014ReqRoomEnter\022\023"
  "\n\006roomId\030\001 \001(\005H\000\210\001\001B\t\n\007_roomId\".\n\014ResRoo"
  "mEnter\022\023\n\006result\030\001 \001(\005H\000\210\001\001B\t\n\007_result\"!"
  "\n\017NtfRoomUserList\022\016\n\006userId\030\001 \003(\t\"0\n\016Ntf"
  "RoomNewUser\022\023\n\006userId\030\001 \001(\tH\000\210\001\001B\t\n\007_use"
  "rId\"\016\n\014ReqRoomLeave\".\n\014ResRoomLeave\022\023\n\006r"
  "esult\030\001 \001(\005H\000\210\001\001B\t\n\007_result\"2\n\020NtfRoomLe"
  "aveUser\022\023\n\006userId\030\001 \001(\tH\000\210\001\001B\t\n\007_userId\""
  ")\n\013ReqRoomChat\022\021\n\004chat\030\001 \001(\tH\000\210\001\001B\007\n\005_ch"
  "at\"I\n\013ResRoomChat\022\023\n\006result\030\001 \001(\005H\000\210\001\001\022\021"
  "\n\004chat\030\002 \001(\tH\001\210\001\001B\t\n\007_resultB\007\n\005_chat\"I\n"
  "\013NtfRoomChat\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\021\n\004cha"
  "t\030\002 \001(\tH\001\210\001\001B\t\n\007_userIdB\007\n\005_chat\"\n\n\010ReqM"
  "atch\"\n\n\010ResMatch\",\n\nNtfMatched\022\023\n\006userId"
  "\030\001 \001(\tH\000\210\001\001B\t\n\007_userId\"\016\n\014ReqReadyOmok\"\016"
  "\n\014ResReadyOmok\",\n\014NtfStartOmok\022\022\n\005black\030"
  "\001 \001(\010H\000\210\001\001B\010\n\006_black\"7\n\tReqPutMok\022\016\n\001x\030\001"
  " \001(\005H\000\210\001\001\022\016\n\001y\030\002 \001(\005H\001\210\001\001B\004\n\002_xB\004\n\002_y\"+\n"
  "\tResPutMok\022\023\n\006result\030\001 \001(\005H\000\210\001\001B\t\n\007_resu"
  "lt\"7\n\tNtfPutMok\022\016\n\001x\030\001 \001(\005H\000\210\001\001\022\016\n\001y\030\002 \001"
  "(\005H\001\210\001\001B\004\n\002_xB\004\n\002_y\"&\n\nNtfEndOmok\022\020\n\003win"
  "\030\001 \001(\010H\000\210\001\001B\006\n\004_winb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_OmokPacket_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_OmokPacket_2eproto = {
    false, false, 987, descriptor_table_protodef_OmokPacket_2eproto,
    "OmokPacket.proto",
    &descriptor_table_OmokPacket_2eproto_once, nullptr, 0, 22,
    schemas, file_default_instances, TableStruct_OmokPacket_2eproto::offsets,
    file_level_metadata_OmokPacket_2eproto, file_level_enum_descriptors_OmokPacket_2eproto,
    file_level_service_descriptors_OmokPacket_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_OmokPacket_2eproto_getter() {
  return &descriptor_table_OmokPacket_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_OmokPacket_2eproto(&descriptor_table_OmokPacket_2eproto);
namespace OmokPacket {

// ===================================================================

class ReqLogin::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqLogin>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReqLogin::ReqLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqLogin)
}
ReqLogin::ReqLogin(const ReqLogin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqLogin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.pw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pw_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pw_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pw()) {
    _this->_impl_.pw_.Set(from._internal_pw(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqLogin)
}

inline void ReqLogin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.pw_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pw_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pw_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqLogin::~ReqLogin() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqLogin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqLogin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
  _impl_.pw_.Destroy();
}

void ReqLogin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqLogin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqLogin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pw_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqLogin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqLogin.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional string pw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pw();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqLogin.pw"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqLogin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqLogin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqLogin.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional string pw = 2;
  if (_internal_has_pw()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pw().data(), static_cast<int>(this->_internal_pw().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqLogin.pw");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqLogin)
  return target;
}

size_t ReqLogin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqLogin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional string pw = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pw());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqLogin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqLogin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqLogin::GetClassData() const { return &_class_data_; }


void ReqLogin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqLogin*>(&to_msg);
  auto& from = static_cast<const ReqLogin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqLogin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pw(from._internal_pw());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqLogin::CopyFrom(const ReqLogin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqLogin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLogin::IsInitialized() const {
  return true;
}

void ReqLogin::InternalSwap(ReqLogin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pw_, lhs_arena,
      &other->_impl_.pw_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqLogin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[0]);
}

// ===================================================================

class ResLogin::_Internal {
 public:
  using HasBits = decltype(std::declval<ResLogin>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResLogin::ResLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResLogin)
}
ResLogin::ResLogin(const ResLogin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResLogin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResLogin)
}

inline void ResLogin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResLogin::~ResLogin() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResLogin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResLogin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResLogin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResLogin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResLogin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResLogin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResLogin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResLogin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResLogin)
  return target;
}

size_t ResLogin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResLogin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResLogin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResLogin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResLogin::GetClassData() const { return &_class_data_; }


void ResLogin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResLogin*>(&to_msg);
  auto& from = static_cast<const ResLogin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResLogin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResLogin::CopyFrom(const ResLogin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResLogin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResLogin::IsInitialized() const {
  return true;
}

void ResLogin::InternalSwap(ResLogin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResLogin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[1]);
}

// ===================================================================

class ReqRoomEnter::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqRoomEnter>()._impl_._has_bits_);
  static void set_has_roomid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqRoomEnter::ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomEnter)
}
ReqRoomEnter::ReqRoomEnter(const ReqRoomEnter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqRoomEnter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roomid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.roomid_ = from._impl_.roomid_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomEnter)
}

inline void ReqRoomEnter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roomid_){0}
  };
}

ReqRoomEnter::~ReqRoomEnter() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqRoomEnter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqRoomEnter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqRoomEnter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqRoomEnter::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqRoomEnter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.roomid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqRoomEnter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 roomId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_roomid(&has_bits);
          _impl_.roomid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqRoomEnter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqRoomEnter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 roomId = 1;
  if (_internal_has_roomid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_roomid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqRoomEnter)
  return target;
}

size_t ReqRoomEnter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqRoomEnter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 roomId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roomid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomEnter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqRoomEnter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomEnter::GetClassData() const { return &_class_data_; }


void ReqRoomEnter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqRoomEnter*>(&to_msg);
  auto& from = static_cast<const ReqRoomEnter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqRoomEnter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_roomid()) {
    _this->_internal_set_roomid(from._internal_roomid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqRoomEnter::CopyFrom(const ReqRoomEnter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqRoomEnter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoomEnter::IsInitialized() const {
  return true;
}

void ReqRoomEnter::InternalSwap(ReqRoomEnter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.roomid_, other->_impl_.roomid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomEnter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[2]);
}

// ===================================================================

class ResRoomEnter::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomEnter>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomEnter::ResRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomEnter)
}
ResRoomEnter::ResRoomEnter(const ResRoomEnter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomEnter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomEnter)
}

inline void ResRoomEnter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResRoomEnter::~ResRoomEnter() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomEnter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomEnter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResRoomEnter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomEnter::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomEnter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomEnter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomEnter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomEnter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomEnter)
  return target;
}

size_t ResRoomEnter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomEnter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomEnter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomEnter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomEnter::GetClassData() const { return &_class_data_; }


void ResRoomEnter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomEnter*>(&to_msg);
  auto& from = static_cast<const ResRoomEnter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomEnter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomEnter::CopyFrom(const ResRoomEnter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomEnter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomEnter::IsInitialized() const {
  return true;
}

void ResRoomEnter::InternalSwap(ResRoomEnter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomEnter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[3]);
}

// ===================================================================

class NtfRoomUserList::_Internal {
 public:
};

NtfRoomUserList::NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomUserList)
}
NtfRoomUserList::NtfRoomUserList(const NtfRoomUserList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomUserList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userid_){from._impl_.userid_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomUserList)
}

inline void NtfRoomUserList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userid_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NtfRoomUserList::~NtfRoomUserList() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomUserList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomUserList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.~RepeatedPtrField();
}

void NtfRoomUserList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomUserList::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomUserList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userid_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomUserList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_userid();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomUserList.userId"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomUserList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomUserList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string userId = 1;
  for (int i = 0, n = this->_internal_userid_size(); i < n; i++) {
    const auto& s = this->_internal_userid(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomUserList.userId");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomUserList)
  return target;
}

size_t NtfRoomUserList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomUserList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string userId = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.userid_.size());
  for (int i = 0, n = _impl_.userid_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.userid_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomUserList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomUserList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomUserList::GetClassData() const { return &_class_data_; }


void NtfRoomUserList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomUserList*>(&to_msg);
  auto& from = static_cast<const NtfRoomUserList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomUserList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.userid_.MergeFrom(from._impl_.userid_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomUserList::CopyFrom(const NtfRoomUserList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomUserList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomUserList::IsInitialized() const {
  return true;
}

void NtfRoomUserList::InternalSwap(NtfRoomUserList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.userid_.InternalSwap(&other->_impl_.userid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomUserList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[4]);
}

// ===================================================================

class NtfRoomNewUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomNewUser>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfRoomNewUser::NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomNewUser)
}
NtfRoomNewUser::NtfRoomNewUser(const NtfRoomNewUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomNewUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomNewUser)
}

inline void NtfRoomNewUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfRoomNewUser::~NtfRoomNewUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomNewUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomNewUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void NtfRoomNewUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomNewUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomNewUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomNewUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomNewUser.userId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomNewUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomNewUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomNewUser.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomNewUser)
  return target;
}

size_t NtfRoomNewUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomNewUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string userId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomNewUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomNewUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomNewUser::GetClassData() const { return &_class_data_; }


void NtfRoomNewUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomNewUser*>(&to_msg);
  auto& from = static_cast<const NtfRoomNewUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomNewUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userid()) {
    _this->_internal_set_userid(from._internal_userid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomNewUser::CopyFrom(const NtfRoomNewUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomNewUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomNewUser::IsInitialized() const {
  return true;
}

void NtfRoomNewUser::InternalSwap(NtfRoomNewUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomNewUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[5]);
}

// ===================================================================

class ReqRoomLeave::_Internal {
 public:
};

ReqRoomLeave::ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomLeave)
}
ReqRoomLeave::ReqRoomLeave(const ReqRoomLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ReqRoomLeave* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomLeave)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomLeave::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[6]);
}

// ===================================================================

class ResRoomLeave::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomLeave>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomLeave::ResRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomLeave)
}
ResRoomLeave::ResRoomLeave(const ResRoomLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomLeave* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomLeave)
}

inline void ResRoomLeave::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResRoomLeave::~ResRoomLeave() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomLeave)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomLeave::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResRoomLeave::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomLeave::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomLeave)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomLeave::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomLeave::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomLeave)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomLeave)
  return target;
}

size_t ResRoomLeave::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomLeave)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomLeave::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomLeave::GetClassData() const { return &_class_data_; }


void ResRoomLeave::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomLeave*>(&to_msg);
  auto& from = static_cast<const ResRoomLeave&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomLeave)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomLeave::CopyFrom(const ResRoomLeave& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomLeave)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomLeave::IsInitialized() const {
  return true;
}

void ResRoomLeave::InternalSwap(ResRoomLeave* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[7]);
}

// ===================================================================

class NtfRoomLeaveUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomLeaveUser>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfRoomLeaveUser::NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomLeaveUser)
}
NtfRoomLeaveUser::NtfRoomLeaveUser(const NtfRoomLeaveUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomLeaveUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomLeaveUser)
}

inline void NtfRoomLeaveUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfRoomLeaveUser::~NtfRoomLeaveUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomLeaveUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomLeaveUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void NtfRoomLeaveUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomLeaveUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomLeaveUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomLeaveUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomLeaveUser.userId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomLeaveUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomLeaveUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomLeaveUser.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomLeaveUser)
  return target;
}

size_t NtfRoomLeaveUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomLeaveUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string userId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomLeaveUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomLeaveUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomLeaveUser::GetClassData() const { return &_class_data_; }


void NtfRoomLeaveUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomLeaveUser*>(&to_msg);
  auto& from = static_cast<const NtfRoomLeaveUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomLeaveUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userid()) {
    _this->_internal_set_userid(from._internal_userid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomLeaveUser::CopyFrom(const NtfRoomLeaveUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomLeaveUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomLeaveUser::IsInitialized() const {
  return true;
}

void NtfRoomLeaveUser::InternalSwap(NtfRoomLeaveUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomLeaveUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[8]);
}

// ===================================================================

class ReqRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqRoomChat>()._impl_._has_bits_);
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqRoomChat::ReqRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomChat)
}
ReqRoomChat::ReqRoomChat(const ReqRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomChat)
}

inline void ReqRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
  };
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqRoomChat::~ReqRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chat_.Destroy();
}

void ReqRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.chat_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string chat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string chat = 1;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqRoomChat)
  return target;
}

size_t ReqRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string chat = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chat());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomChat::GetClassData() const { return &_class_data_; }


void ReqRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqRoomChat*>(&to_msg);
  auto& from = static_cast<const ReqRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_chat()) {
    _this->_internal_set_chat(from._internal_chat());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqRoomChat::CopyFrom(const ReqRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoomChat::IsInitialized() const {
  return true;
}

void ReqRoomChat::InternalSwap(ReqRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[9]);
}

// ===================================================================

class ResRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomChat>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomChat::ResRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomChat)
}
ResRoomChat::ResRoomChat(const ResRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomChat)
}

inline void ResRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
    , decltype(_impl_.result_){0}
  };
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResRoomChat::~ResRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chat_.Destroy();
}

void ResRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.chat_.ClearNonDefaultToEmpty();
  }
  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ResRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ResRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomChat)
  return target;
}

size_t ResRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string chat = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

    // optional int32 result = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomChat::GetClassData() const { return &_class_data_; }


void ResRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomChat*>(&to_msg);
  auto& from = static_cast<const ResRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_chat(from._internal_chat());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomChat::CopyFrom(const ResRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomChat::IsInitialized() const {
  return true;
}

void ResRoomChat::InternalSwap(ResRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[10]);
}

// ===================================================================

class NtfRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomChat>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfRoomChat::NtfRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomChat)
}
NtfRoomChat::NtfRoomChat(const NtfRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomChat)
}

inline void NtfRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chat_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfRoomChat::~NtfRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
  _impl_.chat_.Destroy();
}

void NtfRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.chat_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomChat.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomChat.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomChat)
  return target;
}

size_t NtfRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional string chat = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomChat::GetClassData() const { return &_class_data_; }


void NtfRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomChat*>(&to_msg);
  auto& from = static_cast<const NtfRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_chat(from._internal_chat());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomChat::CopyFrom(const NtfRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomChat::IsInitialized() const {
  return true;
}

void NtfRoomChat::InternalSwap(NtfRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[11]);
}

// ===================================================================

class ReqMatch::_Internal {
 public:
};

ReqMatch::ReqMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqMatch)
}
ReqMatch::ReqMatch(const ReqMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ReqMatch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqMatch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqMatch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ReqMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[12]);
}

// ===================================================================

class ResMatch::_Internal {
 public:
};

ResMatch::ResMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResMatch)
}
ResMatch::ResMatch(const ResMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ResMatch* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResMatch)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResMatch::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ResMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[13]);
}

// ===================================================================

class NtfMatched::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfMatched>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfMatched::NtfMatched(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfMatched)
}
NtfMatched::NtfMatched(const NtfMatched& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfMatched* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfMatched)
}

inline void NtfMatched::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfMatched::~NtfMatched() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfMatched)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfMatched::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void NtfMatched::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfMatched::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfMatched)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfMatched::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfMatched.userId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfMatched::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfMatched)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfMatched.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfMatched)
  return target;
}

size_t NtfMatched::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfMatched)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string userId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfMatched::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfMatched::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfMatched::GetClassData() const { return &_class_data_; }


void NtfMatched::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfMatched*>(&to_msg);
  auto& from = static_cast<const NtfMatched&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfMatched)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userid()) {
    _this->_internal_set_userid(from._internal_userid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfMatched::CopyFrom(const NtfMatched& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfMatched)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfMatched::IsInitialized() const {
  return true;
}

void NtfMatched::InternalSwap(NtfMatched* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfMatched::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[14]);
}

// ===================================================================

class ReqReadyOmok::_Internal {
 public:
};

ReqReadyOmok::ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqReadyOmok)
}
ReqReadyOmok::ReqReadyOmok(const ReqReadyOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ReqReadyOmok* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqReadyOmok)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqReadyOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqReadyOmok::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ReqReadyOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[15]);
}

// ===================================================================

class ResReadyOmok::_Internal {
 public:
};

ResReadyOmok::ResReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResReadyOmok)
}
ResReadyOmok::ResReadyOmok(const ResReadyOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ResReadyOmok* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResReadyOmok)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResReadyOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResReadyOmok::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ResReadyOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[16]);
}

// ===================================================================

class NtfStartOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfStartOmok>()._impl_._has_bits_);
  static void set_has_black(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfStartOmok::NtfStartOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfStartOmok)
}
NtfStartOmok::NtfStartOmok(const NtfStartOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfStartOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.black_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.black_ = from._impl_.black_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfStartOmok)
}

inline void NtfStartOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.black_){false}
  };
}

NtfStartOmok::~NtfStartOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfStartOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfStartOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NtfStartOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfStartOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfStartOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.black_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfStartOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool black = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_black(&has_bits);
          _impl_.black_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfStartOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfStartOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool black = 1;
  if (_internal_has_black()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_black(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfStartOmok)
  return target;
}

size_t NtfStartOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfStartOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool black = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfStartOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfStartOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfStartOmok::GetClassData() const { return &_class_data_; }


void NtfStartOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfStartOmok*>(&to_msg);
  auto& from = static_cast<const NtfStartOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfStartOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_black()) {
    _this->_internal_set_black(from._internal_black());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfStartOmok::CopyFrom(const NtfStartOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfStartOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfStartOmok::IsInitialized() const {
  return true;
}

void NtfStartOmok::InternalSwap(NtfStartOmok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.black_, other->_impl_.black_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfStartOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[17]);
}

// ===================================================================

class ReqPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqPutMok>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReqPutMok::ReqPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqPutMok)
}
ReqPutMok::ReqPutMok(const ReqPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqPutMok)
}

inline void ReqPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

ReqPutMok::~ReqPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqPutMok)
  return target;
}

size_t ReqPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqPutMok::GetClassData() const { return &_class_data_; }


void ReqPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqPutMok*>(&to_msg);
  auto& from = static_cast<const ReqPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqPutMok::CopyFrom(const ReqPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPutMok::IsInitialized() const {
  return true;
}

void ReqPutMok::InternalSwap(ReqPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReqPutMok, _impl_.y_)
      + sizeof(ReqPutMok::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(ReqPutMok, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[18]);
}

// ===================================================================

class ResPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<ResPutMok>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResPutMok::ResPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResPutMok)
}
ResPutMok::ResPutMok(const ResPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResPutMok)
}

inline void ResPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResPutMok::~ResPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResPutMok)
  return target;
}

size_t ResPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResPutMok::GetClassData() const { return &_class_data_; }


void ResPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResPutMok*>(&to_msg);
  auto& from = static_cast<const ResPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResPutMok::CopyFrom(const ResPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResPutMok::IsInitialized() const {
  return true;
}

void ResPutMok::InternalSwap(ResPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[19]);
}

// ===================================================================

class NtfPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfPutMok>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfPutMok::NtfPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfPutMok)
}
NtfPutMok::NtfPutMok(const NtfPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfPutMok)
}

inline void NtfPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

NtfPutMok::~NtfPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NtfPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfPutMok)
  return target;
}

size_t NtfPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfPutMok::GetClassData() const { return &_class_data_; }


void NtfPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfPutMok*>(&to_msg);
  auto& from = static_cast<const NtfPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfPutMok::CopyFrom(const NtfPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfPutMok::IsInitialized() const {
  return true;
}

void NtfPutMok::InternalSwap(NtfPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NtfPutMok, _impl_.y_)
      + sizeof(NtfPutMok::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(NtfPutMok, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[20]);
}

// ===================================================================

class NtfEndOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfEndOmok>()._impl_._has_bits_);
  static void set_has_win(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfEndOmok::NtfEndOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfEndOmok)
}
NtfEndOmok::NtfEndOmok(const NtfEndOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfEndOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.win_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.win_ = from._impl_.win_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfEndOmok)
}

inline void NtfEndOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.win_){false}
  };
}

NtfEndOmok::~NtfEndOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfEndOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfEndOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NtfEndOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfEndOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfEndOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.win_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfEndOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool win = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_win(&has_bits);
          _impl_.win_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfEndOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfEndOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool win = 1;
  if (_internal_has_win()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_win(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfEndOmok)
  return target;
}

size_t NtfEndOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfEndOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool win = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfEndOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfEndOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfEndOmok::GetClassData() const { return &_class_data_; }


void NtfEndOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfEndOmok*>(&to_msg);
  auto& from = static_cast<const NtfEndOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfEndOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_win()) {
    _this->_internal_set_win(from._internal_win());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfEndOmok::CopyFrom(const NtfEndOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfEndOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfEndOmok::IsInitialized() const {
  return true;
}

void NtfEndOmok::InternalSwap(NtfEndOmok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.win_, other->_impl_.win_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfEndOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[21]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace OmokPacket
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqLogin*
Arena::CreateMaybeMessage< ::OmokPacket::ReqLogin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqLogin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResLogin*
Arena::CreateMaybeMessage< ::OmokPacket::ResLogin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResLogin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomEnter*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomEnter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomEnter >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomEnter*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomEnter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomEnter >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomUserList*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomUserList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomUserList >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomNewUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomNewUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomNewUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomLeave*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomLeave*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomLeaveUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomLeaveUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomLeaveUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqMatch*
Arena::CreateMaybeMessage< ::OmokPacket::ReqMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResMatch*
Arena::CreateMaybeMessage< ::OmokPacket::ResMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfMatched*
Arena::CreateMaybeMessage< ::OmokPacket::NtfMatched >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfMatched >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqReadyOmok*
Arena::CreateMaybeMessage< ::OmokPacket::ReqReadyOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqReadyOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResReadyOmok*
Arena::CreateMaybeMessage< ::OmokPacket::ResReadyOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResReadyOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfStartOmok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfStartOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfStartOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::ReqPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::ResPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfEndOmok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfEndOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfEndOmok >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
