// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OmokPacket.proto

#include "OmokPacket.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace OmokPacket {
PROTOBUF_CONSTEXPR ReqLogin::ReqLogin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pw_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqLoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqLoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqLoginDefaultTypeInternal() {}
  union {
    ReqLogin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqLoginDefaultTypeInternal _ReqLogin_default_instance_;
PROTOBUF_CONSTEXPR ResLogin::ResLogin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResLoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResLoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResLoginDefaultTypeInternal() {}
  union {
    ResLogin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResLoginDefaultTypeInternal _ResLogin_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomEnter::ReqRoomEnter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roomid_)*/0} {}
struct ReqRoomEnterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomEnterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomEnterDefaultTypeInternal() {}
  union {
    ReqRoomEnter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomEnterDefaultTypeInternal _ReqRoomEnter_default_instance_;
PROTOBUF_CONSTEXPR ResRoomEnter::ResRoomEnter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userinfo_)*/nullptr
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomEnterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomEnterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomEnterDefaultTypeInternal() {}
  union {
    ResRoomEnter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomEnterDefaultTypeInternal _ResRoomEnter_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomAdmin::NtfRoomAdmin(
    ::_pbi::ConstantInitialized) {}
struct NtfRoomAdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomAdminDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomAdminDefaultTypeInternal() {}
  union {
    NtfRoomAdmin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomAdminDefaultTypeInternal _NtfRoomAdmin_default_instance_;
PROTOBUF_CONSTEXPR NtfNewRoomAdmin::NtfNewRoomAdmin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userinfo_)*/nullptr} {}
struct NtfNewRoomAdminDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfNewRoomAdminDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfNewRoomAdminDefaultTypeInternal() {}
  union {
    NtfNewRoomAdmin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfNewRoomAdminDefaultTypeInternal _NtfNewRoomAdmin_default_instance_;
PROTOBUF_CONSTEXPR UserInfo::UserInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sessionid_)*/0} {}
struct UserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserInfoDefaultTypeInternal() {}
  union {
    UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomUserList::NtfRoomUserList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userinfo_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NtfRoomUserListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomUserListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomUserListDefaultTypeInternal() {}
  union {
    NtfRoomUserList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomUserListDefaultTypeInternal _NtfRoomUserList_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomNewUser::NtfRoomNewUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userinfo_)*/nullptr} {}
struct NtfRoomNewUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomNewUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomNewUserDefaultTypeInternal() {}
  union {
    NtfRoomNewUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomNewUserDefaultTypeInternal _NtfRoomNewUser_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomLeave::ReqRoomLeave(
    ::_pbi::ConstantInitialized) {}
struct ReqRoomLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomLeaveDefaultTypeInternal() {}
  union {
    ReqRoomLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomLeaveDefaultTypeInternal _ReqRoomLeave_default_instance_;
PROTOBUF_CONSTEXPR ResRoomLeave::ResRoomLeave(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomLeaveDefaultTypeInternal() {}
  union {
    ResRoomLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomLeaveDefaultTypeInternal _ResRoomLeave_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomLeaveUser::NtfRoomLeaveUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userinfo_)*/nullptr} {}
struct NtfRoomLeaveUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomLeaveUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomLeaveUserDefaultTypeInternal() {}
  union {
    NtfRoomLeaveUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomLeaveUserDefaultTypeInternal _NtfRoomLeaveUser_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomChat::ReqRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomChatDefaultTypeInternal() {}
  union {
    ReqRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomChatDefaultTypeInternal _ReqRoomChat_default_instance_;
PROTOBUF_CONSTEXPR ResRoomChat::ResRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomChatDefaultTypeInternal() {}
  union {
    ResRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomChatDefaultTypeInternal _ResRoomChat_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomChat::NtfRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.userinfo_)*/nullptr} {}
struct NtfRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomChatDefaultTypeInternal() {}
  union {
    NtfRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomChatDefaultTypeInternal _NtfRoomChat_default_instance_;
PROTOBUF_CONSTEXPR ReqMatch::ReqMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sessionid_)*/0} {}
struct ReqMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqMatchDefaultTypeInternal() {}
  union {
    ReqMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqMatchDefaultTypeInternal _ReqMatch_default_instance_;
PROTOBUF_CONSTEXPR ResMatch::ResMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResMatchDefaultTypeInternal() {}
  union {
    ResMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResMatchDefaultTypeInternal _ResMatch_default_instance_;
PROTOBUF_CONSTEXPR NtfMatchReq::NtfMatchReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userinfo_)*/nullptr} {}
struct NtfMatchReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfMatchReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfMatchReqDefaultTypeInternal() {}
  union {
    NtfMatchReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfMatchReqDefaultTypeInternal _NtfMatchReq_default_instance_;
PROTOBUF_CONSTEXPR ReqMatchRes::ReqMatchRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.accept_)*/false} {}
struct ReqMatchResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqMatchResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqMatchResDefaultTypeInternal() {}
  union {
    ReqMatchRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqMatchResDefaultTypeInternal _ReqMatchRes_default_instance_;
PROTOBUF_CONSTEXPR ReqReadyOmok::ReqReadyOmok(
    ::_pbi::ConstantInitialized) {}
struct ReqReadyOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqReadyOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqReadyOmokDefaultTypeInternal() {}
  union {
    ReqReadyOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqReadyOmokDefaultTypeInternal _ReqReadyOmok_default_instance_;
PROTOBUF_CONSTEXPR ResReadyOmok::ResReadyOmok(
    ::_pbi::ConstantInitialized) {}
struct ResReadyOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResReadyOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResReadyOmokDefaultTypeInternal() {}
  union {
    ResReadyOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResReadyOmokDefaultTypeInternal _ResReadyOmok_default_instance_;
PROTOBUF_CONSTEXPR NtfStartOmok::NtfStartOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.myid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.opponentid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.black_)*/false} {}
struct NtfStartOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfStartOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfStartOmokDefaultTypeInternal() {}
  union {
    NtfStartOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfStartOmokDefaultTypeInternal _NtfStartOmok_default_instance_;
PROTOBUF_CONSTEXPR ReqPutMok::ReqPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct ReqPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqPutMokDefaultTypeInternal() {}
  union {
    ReqPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqPutMokDefaultTypeInternal _ReqPutMok_default_instance_;
PROTOBUF_CONSTEXPR ResPutMok::ResPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResPutMokDefaultTypeInternal() {}
  union {
    ResPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResPutMokDefaultTypeInternal _ResPutMok_default_instance_;
PROTOBUF_CONSTEXPR NtfPutMok::NtfPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct NtfPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfPutMokDefaultTypeInternal() {}
  union {
    NtfPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfPutMokDefaultTypeInternal _NtfPutMok_default_instance_;
PROTOBUF_CONSTEXPR NtfEndOmok::NtfEndOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/0} {}
struct NtfEndOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfEndOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfEndOmokDefaultTypeInternal() {}
  union {
    NtfEndOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfEndOmokDefaultTypeInternal _NtfEndOmok_default_instance_;
PROTOBUF_CONSTEXPR NtfMatchTimeout::NtfMatchTimeout(
    ::_pbi::ConstantInitialized) {}
struct NtfMatchTimeoutDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfMatchTimeoutDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfMatchTimeoutDefaultTypeInternal() {}
  union {
    NtfMatchTimeout _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfMatchTimeoutDefaultTypeInternal _NtfMatchTimeout_default_instance_;
PROTOBUF_CONSTEXPR NtfReadyTimeout::NtfReadyTimeout(
    ::_pbi::ConstantInitialized) {}
struct NtfReadyTimeoutDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfReadyTimeoutDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfReadyTimeoutDefaultTypeInternal() {}
  union {
    NtfReadyTimeout _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfReadyTimeoutDefaultTypeInternal _NtfReadyTimeout_default_instance_;
PROTOBUF_CONSTEXPR NtfPutMokTimeout::NtfPutMokTimeout(
    ::_pbi::ConstantInitialized) {}
struct NtfPutMokTimeoutDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfPutMokTimeoutDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfPutMokTimeoutDefaultTypeInternal() {}
  union {
    NtfPutMokTimeout _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfPutMokTimeoutDefaultTypeInternal _NtfPutMokTimeout_default_instance_;
PROTOBUF_CONSTEXPR NtfStartOmokView::NtfStartOmokView(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.blackid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.whiteid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfStartOmokViewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfStartOmokViewDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfStartOmokViewDefaultTypeInternal() {}
  union {
    NtfStartOmokView _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfStartOmokViewDefaultTypeInternal _NtfStartOmokView_default_instance_;
}  // namespace OmokPacket
static ::_pb::Metadata file_level_metadata_OmokPacket_2eproto[30];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_OmokPacket_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_OmokPacket_2eproto = nullptr;

const uint32_t TableStruct_OmokPacket_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_.pw_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _impl_.roomid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_.userinfo_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomAdmin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfNewRoomAdmin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfNewRoomAdmin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfNewRoomAdmin, _impl_.userinfo_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::UserInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::UserInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::UserInfo, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::UserInfo, _impl_.sessionid_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomUserList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomUserList, _impl_.userinfo_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _impl_.userinfo_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _impl_.userinfo_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_.chat_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_.result_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_.chat_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_.userinfo_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_.chat_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _impl_.sessionid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchReq, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchReq, _impl_.userinfo_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatchRes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatchRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatchRes, _impl_.accept_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqReadyOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResReadyOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_.black_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_.myid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_.opponentid_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _impl_.status_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchTimeout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfReadyTimeout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMokTimeout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmokView, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmokView, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmokView, _impl_.blackid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmokView, _impl_.whiteid_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::OmokPacket::ReqLogin)},
  { 10, 17, -1, sizeof(::OmokPacket::ResLogin)},
  { 18, 25, -1, sizeof(::OmokPacket::ReqRoomEnter)},
  { 26, 34, -1, sizeof(::OmokPacket::ResRoomEnter)},
  { 36, -1, -1, sizeof(::OmokPacket::NtfRoomAdmin)},
  { 42, 49, -1, sizeof(::OmokPacket::NtfNewRoomAdmin)},
  { 50, 58, -1, sizeof(::OmokPacket::UserInfo)},
  { 60, -1, -1, sizeof(::OmokPacket::NtfRoomUserList)},
  { 67, 74, -1, sizeof(::OmokPacket::NtfRoomNewUser)},
  { 75, -1, -1, sizeof(::OmokPacket::ReqRoomLeave)},
  { 81, 88, -1, sizeof(::OmokPacket::ResRoomLeave)},
  { 89, 96, -1, sizeof(::OmokPacket::NtfRoomLeaveUser)},
  { 97, 104, -1, sizeof(::OmokPacket::ReqRoomChat)},
  { 105, 113, -1, sizeof(::OmokPacket::ResRoomChat)},
  { 115, 123, -1, sizeof(::OmokPacket::NtfRoomChat)},
  { 125, 132, -1, sizeof(::OmokPacket::ReqMatch)},
  { 133, 140, -1, sizeof(::OmokPacket::ResMatch)},
  { 141, 148, -1, sizeof(::OmokPacket::NtfMatchReq)},
  { 149, 156, -1, sizeof(::OmokPacket::ReqMatchRes)},
  { 157, -1, -1, sizeof(::OmokPacket::ReqReadyOmok)},
  { 163, -1, -1, sizeof(::OmokPacket::ResReadyOmok)},
  { 169, 178, -1, sizeof(::OmokPacket::NtfStartOmok)},
  { 181, 189, -1, sizeof(::OmokPacket::ReqPutMok)},
  { 191, 198, -1, sizeof(::OmokPacket::ResPutMok)},
  { 199, 207, -1, sizeof(::OmokPacket::NtfPutMok)},
  { 209, 216, -1, sizeof(::OmokPacket::NtfEndOmok)},
  { 217, -1, -1, sizeof(::OmokPacket::NtfMatchTimeout)},
  { 223, -1, -1, sizeof(::OmokPacket::NtfReadyTimeout)},
  { 229, -1, -1, sizeof(::OmokPacket::NtfPutMokTimeout)},
  { 235, 243, -1, sizeof(::OmokPacket::NtfStartOmokView)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::OmokPacket::_ReqLogin_default_instance_._instance,
  &::OmokPacket::_ResLogin_default_instance_._instance,
  &::OmokPacket::_ReqRoomEnter_default_instance_._instance,
  &::OmokPacket::_ResRoomEnter_default_instance_._instance,
  &::OmokPacket::_NtfRoomAdmin_default_instance_._instance,
  &::OmokPacket::_NtfNewRoomAdmin_default_instance_._instance,
  &::OmokPacket::_UserInfo_default_instance_._instance,
  &::OmokPacket::_NtfRoomUserList_default_instance_._instance,
  &::OmokPacket::_NtfRoomNewUser_default_instance_._instance,
  &::OmokPacket::_ReqRoomLeave_default_instance_._instance,
  &::OmokPacket::_ResRoomLeave_default_instance_._instance,
  &::OmokPacket::_NtfRoomLeaveUser_default_instance_._instance,
  &::OmokPacket::_ReqRoomChat_default_instance_._instance,
  &::OmokPacket::_ResRoomChat_default_instance_._instance,
  &::OmokPacket::_NtfRoomChat_default_instance_._instance,
  &::OmokPacket::_ReqMatch_default_instance_._instance,
  &::OmokPacket::_ResMatch_default_instance_._instance,
  &::OmokPacket::_NtfMatchReq_default_instance_._instance,
  &::OmokPacket::_ReqMatchRes_default_instance_._instance,
  &::OmokPacket::_ReqReadyOmok_default_instance_._instance,
  &::OmokPacket::_ResReadyOmok_default_instance_._instance,
  &::OmokPacket::_NtfStartOmok_default_instance_._instance,
  &::OmokPacket::_ReqPutMok_default_instance_._instance,
  &::OmokPacket::_ResPutMok_default_instance_._instance,
  &::OmokPacket::_NtfPutMok_default_instance_._instance,
  &::OmokPacket::_NtfEndOmok_default_instance_._instance,
  &::OmokPacket::_NtfMatchTimeout_default_instance_._instance,
  &::OmokPacket::_NtfReadyTimeout_default_instance_._instance,
  &::OmokPacket::_NtfPutMokTimeout_default_instance_._instance,
  &::OmokPacket::_NtfStartOmokView_default_instance_._instance,
};

const char descriptor_table_protodef_OmokPacket_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020OmokPacket.proto\022\nOmokPacket\"B\n\010ReqLog"
  "in\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\017\n\002pw\030\002 \001(\tH\001\210\001\001"
  "B\t\n\007_userIdB\005\n\003_pw\"*\n\010ResLogin\022\023\n\006result"
  "\030\001 \001(\005H\000\210\001\001B\t\n\007_result\".\n\014ReqRoomEnter\022\023"
  "\n\006roomId\030\001 \001(\005H\000\210\001\001B\t\n\007_roomId\"h\n\014ResRoo"
  "mEnter\022\023\n\006result\030\001 \001(\005H\000\210\001\001\022+\n\010userInfo\030"
  "\002 \001(\0132\024.OmokPacket.UserInfoH\001\210\001\001B\t\n\007_res"
  "ultB\013\n\t_userInfo\"\016\n\014NtfRoomAdmin\"K\n\017NtfN"
  "ewRoomAdmin\022+\n\010userInfo\030\001 \001(\0132\024.OmokPack"
  "et.UserInfoH\000\210\001\001B\013\n\t_userInfo\"P\n\010UserInf"
  "o\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\026\n\tsessionId\030\002 \001("
  "\005H\001\210\001\001B\t\n\007_userIdB\014\n\n_sessionId\"9\n\017NtfRo"
  "omUserList\022&\n\010userInfo\030\001 \003(\0132\024.OmokPacke"
  "t.UserInfo\"J\n\016NtfRoomNewUser\022+\n\010userInfo"
  "\030\001 \001(\0132\024.OmokPacket.UserInfoH\000\210\001\001B\013\n\t_us"
  "erInfo\"\016\n\014ReqRoomLeave\".\n\014ResRoomLeave\022\023"
  "\n\006result\030\001 \001(\005H\000\210\001\001B\t\n\007_result\"L\n\020NtfRoo"
  "mLeaveUser\022+\n\010userInfo\030\001 \001(\0132\024.OmokPacke"
  "t.UserInfoH\000\210\001\001B\013\n\t_userInfo\")\n\013ReqRoomC"
  "hat\022\021\n\004chat\030\001 \001(\tH\000\210\001\001B\007\n\005_chat\"I\n\013ResRo"
  "omChat\022\023\n\006result\030\001 \001(\005H\000\210\001\001\022\021\n\004chat\030\002 \001("
  "\tH\001\210\001\001B\t\n\007_resultB\007\n\005_chat\"c\n\013NtfRoomCha"
  "t\022+\n\010userInfo\030\001 \001(\0132\024.OmokPacket.UserInf"
  "oH\000\210\001\001\022\021\n\004chat\030\002 \001(\tH\001\210\001\001B\013\n\t_userInfoB\007"
  "\n\005_chat\"0\n\010ReqMatch\022\026\n\tsessionId\030\001 \001(\005H\000"
  "\210\001\001B\014\n\n_sessionId\"*\n\010ResMatch\022\023\n\006result\030"
  "\001 \001(\005H\000\210\001\001B\t\n\007_result\"G\n\013NtfMatchReq\022+\n\010"
  "userInfo\030\001 \001(\0132\024.OmokPacket.UserInfoH\000\210\001"
  "\001B\013\n\t_userInfo\"-\n\013ReqMatchRes\022\023\n\006accept\030"
  "\001 \001(\010H\000\210\001\001B\t\n\007_accept\"\016\n\014ReqReadyOmok\"\016\n"
  "\014ResReadyOmok\"p\n\014NtfStartOmok\022\022\n\005black\030\001"
  " \001(\010H\000\210\001\001\022\021\n\004myId\030\002 \001(\tH\001\210\001\001\022\027\n\nopponent"
  "Id\030\003 \001(\tH\002\210\001\001B\010\n\006_blackB\007\n\005_myIdB\r\n\013_opp"
  "onentId\"7\n\tReqPutMok\022\016\n\001x\030\001 \001(\005H\000\210\001\001\022\016\n\001"
  "y\030\002 \001(\005H\001\210\001\001B\004\n\002_xB\004\n\002_y\"+\n\tResPutMok\022\023\n"
  "\006result\030\001 \001(\005H\000\210\001\001B\t\n\007_result\"7\n\tNtfPutM"
  "ok\022\016\n\001x\030\001 \001(\005H\000\210\001\001\022\016\n\001y\030\002 \001(\005H\001\210\001\001B\004\n\002_x"
  "B\004\n\002_y\",\n\nNtfEndOmok\022\023\n\006status\030\001 \001(\005H\000\210\001"
  "\001B\t\n\007_status\"\021\n\017NtfMatchTimeout\"\021\n\017NtfRe"
  "adyTimeout\"\022\n\020NtfPutMokTimeout\"V\n\020NtfSta"
  "rtOmokView\022\024\n\007blackId\030\001 \001(\tH\000\210\001\001\022\024\n\007whit"
  "eId\030\002 \001(\tH\001\210\001\001B\n\n\010_blackIdB\n\n\010_whiteIdb\006"
  "proto3"
  ;
static ::_pbi::once_flag descriptor_table_OmokPacket_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_OmokPacket_2eproto = {
    false, false, 1686, descriptor_table_protodef_OmokPacket_2eproto,
    "OmokPacket.proto",
    &descriptor_table_OmokPacket_2eproto_once, nullptr, 0, 30,
    schemas, file_default_instances, TableStruct_OmokPacket_2eproto::offsets,
    file_level_metadata_OmokPacket_2eproto, file_level_enum_descriptors_OmokPacket_2eproto,
    file_level_service_descriptors_OmokPacket_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_OmokPacket_2eproto_getter() {
  return &descriptor_table_OmokPacket_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_OmokPacket_2eproto(&descriptor_table_OmokPacket_2eproto);
namespace OmokPacket {

// ===================================================================

class ReqLogin::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqLogin>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReqLogin::ReqLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqLogin)
}
ReqLogin::ReqLogin(const ReqLogin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqLogin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.pw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pw_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pw_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pw()) {
    _this->_impl_.pw_.Set(from._internal_pw(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqLogin)
}

inline void ReqLogin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.pw_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pw_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pw_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqLogin::~ReqLogin() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqLogin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqLogin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
  _impl_.pw_.Destroy();
}

void ReqLogin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqLogin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqLogin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pw_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqLogin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqLogin.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional string pw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pw();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqLogin.pw"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqLogin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqLogin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqLogin.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional string pw = 2;
  if (_internal_has_pw()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pw().data(), static_cast<int>(this->_internal_pw().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqLogin.pw");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqLogin)
  return target;
}

size_t ReqLogin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqLogin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional string pw = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pw());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqLogin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqLogin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqLogin::GetClassData() const { return &_class_data_; }


void ReqLogin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqLogin*>(&to_msg);
  auto& from = static_cast<const ReqLogin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqLogin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pw(from._internal_pw());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqLogin::CopyFrom(const ReqLogin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqLogin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLogin::IsInitialized() const {
  return true;
}

void ReqLogin::InternalSwap(ReqLogin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pw_, lhs_arena,
      &other->_impl_.pw_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqLogin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[0]);
}

// ===================================================================

class ResLogin::_Internal {
 public:
  using HasBits = decltype(std::declval<ResLogin>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResLogin::ResLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResLogin)
}
ResLogin::ResLogin(const ResLogin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResLogin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResLogin)
}

inline void ResLogin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResLogin::~ResLogin() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResLogin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResLogin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResLogin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResLogin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResLogin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResLogin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResLogin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResLogin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResLogin)
  return target;
}

size_t ResLogin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResLogin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResLogin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResLogin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResLogin::GetClassData() const { return &_class_data_; }


void ResLogin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResLogin*>(&to_msg);
  auto& from = static_cast<const ResLogin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResLogin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResLogin::CopyFrom(const ResLogin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResLogin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResLogin::IsInitialized() const {
  return true;
}

void ResLogin::InternalSwap(ResLogin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResLogin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[1]);
}

// ===================================================================

class ReqRoomEnter::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqRoomEnter>()._impl_._has_bits_);
  static void set_has_roomid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqRoomEnter::ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomEnter)
}
ReqRoomEnter::ReqRoomEnter(const ReqRoomEnter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqRoomEnter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roomid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.roomid_ = from._impl_.roomid_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomEnter)
}

inline void ReqRoomEnter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roomid_){0}
  };
}

ReqRoomEnter::~ReqRoomEnter() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqRoomEnter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqRoomEnter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqRoomEnter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqRoomEnter::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqRoomEnter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.roomid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqRoomEnter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 roomId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_roomid(&has_bits);
          _impl_.roomid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqRoomEnter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqRoomEnter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 roomId = 1;
  if (_internal_has_roomid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_roomid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqRoomEnter)
  return target;
}

size_t ReqRoomEnter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqRoomEnter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 roomId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roomid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomEnter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqRoomEnter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomEnter::GetClassData() const { return &_class_data_; }


void ReqRoomEnter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqRoomEnter*>(&to_msg);
  auto& from = static_cast<const ReqRoomEnter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqRoomEnter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_roomid()) {
    _this->_internal_set_roomid(from._internal_roomid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqRoomEnter::CopyFrom(const ReqRoomEnter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqRoomEnter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoomEnter::IsInitialized() const {
  return true;
}

void ReqRoomEnter::InternalSwap(ReqRoomEnter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.roomid_, other->_impl_.roomid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomEnter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[2]);
}

// ===================================================================

class ResRoomEnter::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomEnter>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::OmokPacket::UserInfo& userinfo(const ResRoomEnter* msg);
  static void set_has_userinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::UserInfo&
ResRoomEnter::_Internal::userinfo(const ResRoomEnter* msg) {
  return *msg->_impl_.userinfo_;
}
ResRoomEnter::ResRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomEnter)
}
ResRoomEnter::ResRoomEnter(const ResRoomEnter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomEnter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_userinfo()) {
    _this->_impl_.userinfo_ = new ::OmokPacket::UserInfo(*from._impl_.userinfo_);
  }
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomEnter)
}

inline void ResRoomEnter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}
    , decltype(_impl_.result_){0}
  };
}

ResRoomEnter::~ResRoomEnter() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomEnter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomEnter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.userinfo_;
}

void ResRoomEnter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomEnter::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomEnter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.userinfo_ != nullptr);
    _impl_.userinfo_->Clear();
  }
  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomEnter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .OmokPacket.UserInfo userInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_userinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomEnter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomEnter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  // optional .OmokPacket.UserInfo userInfo = 2;
  if (_internal_has_userinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::userinfo(this),
        _Internal::userinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomEnter)
  return target;
}

size_t ResRoomEnter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomEnter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .OmokPacket.UserInfo userInfo = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.userinfo_);
    }

    // optional int32 result = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomEnter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomEnter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomEnter::GetClassData() const { return &_class_data_; }


void ResRoomEnter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomEnter*>(&to_msg);
  auto& from = static_cast<const ResRoomEnter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomEnter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_userinfo()->::OmokPacket::UserInfo::MergeFrom(
          from._internal_userinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomEnter::CopyFrom(const ResRoomEnter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomEnter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomEnter::IsInitialized() const {
  return true;
}

void ResRoomEnter::InternalSwap(ResRoomEnter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResRoomEnter, _impl_.result_)
      + sizeof(ResRoomEnter::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(ResRoomEnter, _impl_.userinfo_)>(
          reinterpret_cast<char*>(&_impl_.userinfo_),
          reinterpret_cast<char*>(&other->_impl_.userinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomEnter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[3]);
}

// ===================================================================

class NtfRoomAdmin::_Internal {
 public:
};

NtfRoomAdmin::NtfRoomAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomAdmin)
}
NtfRoomAdmin::NtfRoomAdmin(const NtfRoomAdmin& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  NtfRoomAdmin* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomAdmin)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomAdmin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomAdmin::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomAdmin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[4]);
}

// ===================================================================

class NtfNewRoomAdmin::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfNewRoomAdmin>()._impl_._has_bits_);
  static const ::OmokPacket::UserInfo& userinfo(const NtfNewRoomAdmin* msg);
  static void set_has_userinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::UserInfo&
NtfNewRoomAdmin::_Internal::userinfo(const NtfNewRoomAdmin* msg) {
  return *msg->_impl_.userinfo_;
}
NtfNewRoomAdmin::NtfNewRoomAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfNewRoomAdmin)
}
NtfNewRoomAdmin::NtfNewRoomAdmin(const NtfNewRoomAdmin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfNewRoomAdmin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_userinfo()) {
    _this->_impl_.userinfo_ = new ::OmokPacket::UserInfo(*from._impl_.userinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfNewRoomAdmin)
}

inline void NtfNewRoomAdmin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}
  };
}

NtfNewRoomAdmin::~NtfNewRoomAdmin() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfNewRoomAdmin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfNewRoomAdmin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.userinfo_;
}

void NtfNewRoomAdmin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfNewRoomAdmin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfNewRoomAdmin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.userinfo_ != nullptr);
    _impl_.userinfo_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfNewRoomAdmin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.UserInfo userInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_userinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfNewRoomAdmin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfNewRoomAdmin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  if (_internal_has_userinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::userinfo(this),
        _Internal::userinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfNewRoomAdmin)
  return target;
}

size_t NtfNewRoomAdmin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfNewRoomAdmin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.userinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfNewRoomAdmin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfNewRoomAdmin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfNewRoomAdmin::GetClassData() const { return &_class_data_; }


void NtfNewRoomAdmin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfNewRoomAdmin*>(&to_msg);
  auto& from = static_cast<const NtfNewRoomAdmin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfNewRoomAdmin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userinfo()) {
    _this->_internal_mutable_userinfo()->::OmokPacket::UserInfo::MergeFrom(
        from._internal_userinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfNewRoomAdmin::CopyFrom(const NtfNewRoomAdmin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfNewRoomAdmin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfNewRoomAdmin::IsInitialized() const {
  return true;
}

void NtfNewRoomAdmin::InternalSwap(NtfNewRoomAdmin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.userinfo_, other->_impl_.userinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfNewRoomAdmin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[5]);
}

// ===================================================================

class UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserInfo>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.sessionid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.sessionid_ = from._impl_.sessionid_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.UserInfo)
}

inline void UserInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.sessionid_){0}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:OmokPacket.UserInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void UserInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_.sessionid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.UserInfo.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 sessionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sessionid(&has_bits);
          _impl_.sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.UserInfo.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional int32 sessionId = 2;
  if (_internal_has_sessionid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sessionid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.UserInfo)
  return target;
}

size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.UserInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional int32 sessionId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sessionid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserInfo::GetClassData() const { return &_class_data_; }


void UserInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserInfo*>(&to_msg);
  auto& from = static_cast<const UserInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.UserInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sessionid_ = from._impl_.sessionid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  return true;
}

void UserInfo::InternalSwap(UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  swap(_impl_.sessionid_, other->_impl_.sessionid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[6]);
}

// ===================================================================

class NtfRoomUserList::_Internal {
 public:
};

NtfRoomUserList::NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomUserList)
}
NtfRoomUserList::NtfRoomUserList(const NtfRoomUserList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomUserList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userinfo_){from._impl_.userinfo_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomUserList)
}

inline void NtfRoomUserList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userinfo_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NtfRoomUserList::~NtfRoomUserList() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomUserList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomUserList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userinfo_.~RepeatedPtrField();
}

void NtfRoomUserList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomUserList::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomUserList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userinfo_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomUserList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .OmokPacket.UserInfo userInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_userinfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomUserList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomUserList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .OmokPacket.UserInfo userInfo = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_userinfo_size()); i < n; i++) {
    const auto& repfield = this->_internal_userinfo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomUserList)
  return target;
}

size_t NtfRoomUserList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomUserList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .OmokPacket.UserInfo userInfo = 1;
  total_size += 1UL * this->_internal_userinfo_size();
  for (const auto& msg : this->_impl_.userinfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomUserList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomUserList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomUserList::GetClassData() const { return &_class_data_; }


void NtfRoomUserList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomUserList*>(&to_msg);
  auto& from = static_cast<const NtfRoomUserList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomUserList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.userinfo_.MergeFrom(from._impl_.userinfo_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomUserList::CopyFrom(const NtfRoomUserList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomUserList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomUserList::IsInitialized() const {
  return true;
}

void NtfRoomUserList::InternalSwap(NtfRoomUserList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.userinfo_.InternalSwap(&other->_impl_.userinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomUserList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[7]);
}

// ===================================================================

class NtfRoomNewUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomNewUser>()._impl_._has_bits_);
  static const ::OmokPacket::UserInfo& userinfo(const NtfRoomNewUser* msg);
  static void set_has_userinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::UserInfo&
NtfRoomNewUser::_Internal::userinfo(const NtfRoomNewUser* msg) {
  return *msg->_impl_.userinfo_;
}
NtfRoomNewUser::NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomNewUser)
}
NtfRoomNewUser::NtfRoomNewUser(const NtfRoomNewUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomNewUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_userinfo()) {
    _this->_impl_.userinfo_ = new ::OmokPacket::UserInfo(*from._impl_.userinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomNewUser)
}

inline void NtfRoomNewUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}
  };
}

NtfRoomNewUser::~NtfRoomNewUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomNewUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomNewUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.userinfo_;
}

void NtfRoomNewUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomNewUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomNewUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.userinfo_ != nullptr);
    _impl_.userinfo_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomNewUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.UserInfo userInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_userinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomNewUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomNewUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  if (_internal_has_userinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::userinfo(this),
        _Internal::userinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomNewUser)
  return target;
}

size_t NtfRoomNewUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomNewUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.userinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomNewUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomNewUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomNewUser::GetClassData() const { return &_class_data_; }


void NtfRoomNewUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomNewUser*>(&to_msg);
  auto& from = static_cast<const NtfRoomNewUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomNewUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userinfo()) {
    _this->_internal_mutable_userinfo()->::OmokPacket::UserInfo::MergeFrom(
        from._internal_userinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomNewUser::CopyFrom(const NtfRoomNewUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomNewUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomNewUser::IsInitialized() const {
  return true;
}

void NtfRoomNewUser::InternalSwap(NtfRoomNewUser* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.userinfo_, other->_impl_.userinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomNewUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[8]);
}

// ===================================================================

class ReqRoomLeave::_Internal {
 public:
};

ReqRoomLeave::ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomLeave)
}
ReqRoomLeave::ReqRoomLeave(const ReqRoomLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ReqRoomLeave* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomLeave)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomLeave::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[9]);
}

// ===================================================================

class ResRoomLeave::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomLeave>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomLeave::ResRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomLeave)
}
ResRoomLeave::ResRoomLeave(const ResRoomLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomLeave* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomLeave)
}

inline void ResRoomLeave::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResRoomLeave::~ResRoomLeave() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomLeave)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomLeave::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResRoomLeave::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomLeave::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomLeave)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomLeave::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomLeave::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomLeave)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomLeave)
  return target;
}

size_t ResRoomLeave::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomLeave)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomLeave::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomLeave::GetClassData() const { return &_class_data_; }


void ResRoomLeave::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomLeave*>(&to_msg);
  auto& from = static_cast<const ResRoomLeave&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomLeave)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomLeave::CopyFrom(const ResRoomLeave& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomLeave)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomLeave::IsInitialized() const {
  return true;
}

void ResRoomLeave::InternalSwap(ResRoomLeave* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[10]);
}

// ===================================================================

class NtfRoomLeaveUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomLeaveUser>()._impl_._has_bits_);
  static const ::OmokPacket::UserInfo& userinfo(const NtfRoomLeaveUser* msg);
  static void set_has_userinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::UserInfo&
NtfRoomLeaveUser::_Internal::userinfo(const NtfRoomLeaveUser* msg) {
  return *msg->_impl_.userinfo_;
}
NtfRoomLeaveUser::NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomLeaveUser)
}
NtfRoomLeaveUser::NtfRoomLeaveUser(const NtfRoomLeaveUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomLeaveUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_userinfo()) {
    _this->_impl_.userinfo_ = new ::OmokPacket::UserInfo(*from._impl_.userinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomLeaveUser)
}

inline void NtfRoomLeaveUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}
  };
}

NtfRoomLeaveUser::~NtfRoomLeaveUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomLeaveUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomLeaveUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.userinfo_;
}

void NtfRoomLeaveUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomLeaveUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomLeaveUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.userinfo_ != nullptr);
    _impl_.userinfo_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomLeaveUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.UserInfo userInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_userinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomLeaveUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomLeaveUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  if (_internal_has_userinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::userinfo(this),
        _Internal::userinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomLeaveUser)
  return target;
}

size_t NtfRoomLeaveUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomLeaveUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.userinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomLeaveUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomLeaveUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomLeaveUser::GetClassData() const { return &_class_data_; }


void NtfRoomLeaveUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomLeaveUser*>(&to_msg);
  auto& from = static_cast<const NtfRoomLeaveUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomLeaveUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userinfo()) {
    _this->_internal_mutable_userinfo()->::OmokPacket::UserInfo::MergeFrom(
        from._internal_userinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomLeaveUser::CopyFrom(const NtfRoomLeaveUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomLeaveUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomLeaveUser::IsInitialized() const {
  return true;
}

void NtfRoomLeaveUser::InternalSwap(NtfRoomLeaveUser* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.userinfo_, other->_impl_.userinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomLeaveUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[11]);
}

// ===================================================================

class ReqRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqRoomChat>()._impl_._has_bits_);
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqRoomChat::ReqRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomChat)
}
ReqRoomChat::ReqRoomChat(const ReqRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomChat)
}

inline void ReqRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
  };
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqRoomChat::~ReqRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chat_.Destroy();
}

void ReqRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.chat_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string chat = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string chat = 1;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqRoomChat)
  return target;
}

size_t ReqRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string chat = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chat());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomChat::GetClassData() const { return &_class_data_; }


void ReqRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqRoomChat*>(&to_msg);
  auto& from = static_cast<const ReqRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_chat()) {
    _this->_internal_set_chat(from._internal_chat());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqRoomChat::CopyFrom(const ReqRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoomChat::IsInitialized() const {
  return true;
}

void ReqRoomChat::InternalSwap(ReqRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[12]);
}

// ===================================================================

class ResRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomChat>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomChat::ResRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomChat)
}
ResRoomChat::ResRoomChat(const ResRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomChat)
}

inline void ResRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
    , decltype(_impl_.result_){0}
  };
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResRoomChat::~ResRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chat_.Destroy();
}

void ResRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.chat_.ClearNonDefaultToEmpty();
  }
  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ResRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ResRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomChat)
  return target;
}

size_t ResRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string chat = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

    // optional int32 result = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomChat::GetClassData() const { return &_class_data_; }


void ResRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomChat*>(&to_msg);
  auto& from = static_cast<const ResRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_chat(from._internal_chat());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.result_ = from._impl_.result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomChat::CopyFrom(const ResRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomChat::IsInitialized() const {
  return true;
}

void ResRoomChat::InternalSwap(ResRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[13]);
}

// ===================================================================

class NtfRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomChat>()._impl_._has_bits_);
  static const ::OmokPacket::UserInfo& userinfo(const NtfRoomChat* msg);
  static void set_has_userinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::UserInfo&
NtfRoomChat::_Internal::userinfo(const NtfRoomChat* msg) {
  return *msg->_impl_.userinfo_;
}
NtfRoomChat::NtfRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomChat)
}
NtfRoomChat::NtfRoomChat(const NtfRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
    , decltype(_impl_.userinfo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_userinfo()) {
    _this->_impl_.userinfo_ = new ::OmokPacket::UserInfo(*from._impl_.userinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomChat)
}

inline void NtfRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chat_){}
    , decltype(_impl_.userinfo_){nullptr}
  };
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfRoomChat::~NtfRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chat_.Destroy();
  if (this != internal_default_instance()) delete _impl_.userinfo_;
}

void NtfRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.chat_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.userinfo_ != nullptr);
      _impl_.userinfo_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.UserInfo userInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_userinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  if (_internal_has_userinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::userinfo(this),
        _Internal::userinfo(this).GetCachedSize(), target, stream);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomChat)
  return target;
}

size_t NtfRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string chat = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

    // optional .OmokPacket.UserInfo userInfo = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.userinfo_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomChat::GetClassData() const { return &_class_data_; }


void NtfRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomChat*>(&to_msg);
  auto& from = static_cast<const NtfRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_chat(from._internal_chat());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_userinfo()->::OmokPacket::UserInfo::MergeFrom(
          from._internal_userinfo());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomChat::CopyFrom(const NtfRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomChat::IsInitialized() const {
  return true;
}

void NtfRoomChat::InternalSwap(NtfRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
  swap(_impl_.userinfo_, other->_impl_.userinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[14]);
}

// ===================================================================

class ReqMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqMatch>()._impl_._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqMatch::ReqMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqMatch)
}
ReqMatch::ReqMatch(const ReqMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sessionid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sessionid_ = from._impl_.sessionid_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqMatch)
}

inline void ReqMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sessionid_){0}
  };
}

ReqMatch::~ReqMatch() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sessionid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sessionId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sessionid(&has_bits);
          _impl_.sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 sessionId = 1;
  if (_internal_has_sessionid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sessionid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqMatch)
  return target;
}

size_t ReqMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 sessionId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sessionid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqMatch::GetClassData() const { return &_class_data_; }


void ReqMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqMatch*>(&to_msg);
  auto& from = static_cast<const ReqMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sessionid()) {
    _this->_internal_set_sessionid(from._internal_sessionid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqMatch::CopyFrom(const ReqMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqMatch::IsInitialized() const {
  return true;
}

void ReqMatch::InternalSwap(ReqMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.sessionid_, other->_impl_.sessionid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[15]);
}

// ===================================================================

class ResMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ResMatch>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResMatch::ResMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResMatch)
}
ResMatch::ResMatch(const ResMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResMatch)
}

inline void ResMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResMatch::~ResMatch() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResMatch)
  return target;
}

size_t ResMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResMatch::GetClassData() const { return &_class_data_; }


void ResMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResMatch*>(&to_msg);
  auto& from = static_cast<const ResMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResMatch::CopyFrom(const ResMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResMatch::IsInitialized() const {
  return true;
}

void ResMatch::InternalSwap(ResMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[16]);
}

// ===================================================================

class NtfMatchReq::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfMatchReq>()._impl_._has_bits_);
  static const ::OmokPacket::UserInfo& userinfo(const NtfMatchReq* msg);
  static void set_has_userinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::UserInfo&
NtfMatchReq::_Internal::userinfo(const NtfMatchReq* msg) {
  return *msg->_impl_.userinfo_;
}
NtfMatchReq::NtfMatchReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfMatchReq)
}
NtfMatchReq::NtfMatchReq(const NtfMatchReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfMatchReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_userinfo()) {
    _this->_impl_.userinfo_ = new ::OmokPacket::UserInfo(*from._impl_.userinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfMatchReq)
}

inline void NtfMatchReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userinfo_){nullptr}
  };
}

NtfMatchReq::~NtfMatchReq() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfMatchReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfMatchReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.userinfo_;
}

void NtfMatchReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfMatchReq::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfMatchReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.userinfo_ != nullptr);
    _impl_.userinfo_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfMatchReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.UserInfo userInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_userinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfMatchReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfMatchReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  if (_internal_has_userinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::userinfo(this),
        _Internal::userinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfMatchReq)
  return target;
}

size_t NtfMatchReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfMatchReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .OmokPacket.UserInfo userInfo = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.userinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfMatchReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfMatchReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfMatchReq::GetClassData() const { return &_class_data_; }


void NtfMatchReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfMatchReq*>(&to_msg);
  auto& from = static_cast<const NtfMatchReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfMatchReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userinfo()) {
    _this->_internal_mutable_userinfo()->::OmokPacket::UserInfo::MergeFrom(
        from._internal_userinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfMatchReq::CopyFrom(const NtfMatchReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfMatchReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfMatchReq::IsInitialized() const {
  return true;
}

void NtfMatchReq::InternalSwap(NtfMatchReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.userinfo_, other->_impl_.userinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfMatchReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[17]);
}

// ===================================================================

class ReqMatchRes::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqMatchRes>()._impl_._has_bits_);
  static void set_has_accept(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqMatchRes::ReqMatchRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqMatchRes)
}
ReqMatchRes::ReqMatchRes(const ReqMatchRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqMatchRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accept_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.accept_ = from._impl_.accept_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqMatchRes)
}

inline void ReqMatchRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accept_){false}
  };
}

ReqMatchRes::~ReqMatchRes() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqMatchRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqMatchRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqMatchRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqMatchRes::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqMatchRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accept_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqMatchRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool accept = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_accept(&has_bits);
          _impl_.accept_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqMatchRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqMatchRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool accept = 1;
  if (_internal_has_accept()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_accept(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqMatchRes)
  return target;
}

size_t ReqMatchRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqMatchRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool accept = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqMatchRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqMatchRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqMatchRes::GetClassData() const { return &_class_data_; }


void ReqMatchRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqMatchRes*>(&to_msg);
  auto& from = static_cast<const ReqMatchRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqMatchRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_accept()) {
    _this->_internal_set_accept(from._internal_accept());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqMatchRes::CopyFrom(const ReqMatchRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqMatchRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqMatchRes::IsInitialized() const {
  return true;
}

void ReqMatchRes::InternalSwap(ReqMatchRes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.accept_, other->_impl_.accept_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqMatchRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[18]);
}

// ===================================================================

class ReqReadyOmok::_Internal {
 public:
};

ReqReadyOmok::ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqReadyOmok)
}
ReqReadyOmok::ReqReadyOmok(const ReqReadyOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ReqReadyOmok* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqReadyOmok)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqReadyOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqReadyOmok::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ReqReadyOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[19]);
}

// ===================================================================

class ResReadyOmok::_Internal {
 public:
};

ResReadyOmok::ResReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResReadyOmok)
}
ResReadyOmok::ResReadyOmok(const ResReadyOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ResReadyOmok* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResReadyOmok)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResReadyOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResReadyOmok::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ResReadyOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[20]);
}

// ===================================================================

class NtfStartOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfStartOmok>()._impl_._has_bits_);
  static void set_has_black(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_myid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_opponentid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfStartOmok::NtfStartOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfStartOmok)
}
NtfStartOmok::NtfStartOmok(const NtfStartOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfStartOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.myid_){}
    , decltype(_impl_.opponentid_){}
    , decltype(_impl_.black_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.myid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.myid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_myid()) {
    _this->_impl_.myid_.Set(from._internal_myid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.opponentid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.opponentid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_opponentid()) {
    _this->_impl_.opponentid_.Set(from._internal_opponentid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.black_ = from._impl_.black_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfStartOmok)
}

inline void NtfStartOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.myid_){}
    , decltype(_impl_.opponentid_){}
    , decltype(_impl_.black_){false}
  };
  _impl_.myid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.myid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.opponentid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.opponentid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfStartOmok::~NtfStartOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfStartOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfStartOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.myid_.Destroy();
  _impl_.opponentid_.Destroy();
}

void NtfStartOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfStartOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfStartOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.myid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.opponentid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.black_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfStartOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool black = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_black(&has_bits);
          _impl_.black_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string myId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_myid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfStartOmok.myId"));
        } else
          goto handle_unusual;
        continue;
      // optional string opponentId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_opponentid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfStartOmok.opponentId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfStartOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfStartOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool black = 1;
  if (_internal_has_black()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_black(), target);
  }

  // optional string myId = 2;
  if (_internal_has_myid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_myid().data(), static_cast<int>(this->_internal_myid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfStartOmok.myId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_myid(), target);
  }

  // optional string opponentId = 3;
  if (_internal_has_opponentid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_opponentid().data(), static_cast<int>(this->_internal_opponentid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfStartOmok.opponentId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_opponentid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfStartOmok)
  return target;
}

size_t NtfStartOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfStartOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string myId = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_myid());
    }

    // optional string opponentId = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_opponentid());
    }

    // optional bool black = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfStartOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfStartOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfStartOmok::GetClassData() const { return &_class_data_; }


void NtfStartOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfStartOmok*>(&to_msg);
  auto& from = static_cast<const NtfStartOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfStartOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_myid(from._internal_myid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_opponentid(from._internal_opponentid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.black_ = from._impl_.black_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfStartOmok::CopyFrom(const NtfStartOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfStartOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfStartOmok::IsInitialized() const {
  return true;
}

void NtfStartOmok::InternalSwap(NtfStartOmok* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.myid_, lhs_arena,
      &other->_impl_.myid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.opponentid_, lhs_arena,
      &other->_impl_.opponentid_, rhs_arena
  );
  swap(_impl_.black_, other->_impl_.black_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfStartOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[21]);
}

// ===================================================================

class ReqPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqPutMok>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReqPutMok::ReqPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqPutMok)
}
ReqPutMok::ReqPutMok(const ReqPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqPutMok)
}

inline void ReqPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

ReqPutMok::~ReqPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqPutMok)
  return target;
}

size_t ReqPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqPutMok::GetClassData() const { return &_class_data_; }


void ReqPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqPutMok*>(&to_msg);
  auto& from = static_cast<const ReqPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqPutMok::CopyFrom(const ReqPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPutMok::IsInitialized() const {
  return true;
}

void ReqPutMok::InternalSwap(ReqPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReqPutMok, _impl_.y_)
      + sizeof(ReqPutMok::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(ReqPutMok, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[22]);
}

// ===================================================================

class ResPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<ResPutMok>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResPutMok::ResPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResPutMok)
}
ResPutMok::ResPutMok(const ResPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResPutMok)
}

inline void ResPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResPutMok::~ResPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResPutMok)
  return target;
}

size_t ResPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResPutMok::GetClassData() const { return &_class_data_; }


void ResPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResPutMok*>(&to_msg);
  auto& from = static_cast<const ResPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResPutMok::CopyFrom(const ResPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResPutMok::IsInitialized() const {
  return true;
}

void ResPutMok::InternalSwap(ResPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[23]);
}

// ===================================================================

class NtfPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfPutMok>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfPutMok::NtfPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfPutMok)
}
NtfPutMok::NtfPutMok(const NtfPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfPutMok)
}

inline void NtfPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

NtfPutMok::~NtfPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NtfPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfPutMok)
  return target;
}

size_t NtfPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfPutMok::GetClassData() const { return &_class_data_; }


void NtfPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfPutMok*>(&to_msg);
  auto& from = static_cast<const NtfPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfPutMok::CopyFrom(const NtfPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfPutMok::IsInitialized() const {
  return true;
}

void NtfPutMok::InternalSwap(NtfPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NtfPutMok, _impl_.y_)
      + sizeof(NtfPutMok::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(NtfPutMok, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[24]);
}

// ===================================================================

class NtfEndOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfEndOmok>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfEndOmok::NtfEndOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfEndOmok)
}
NtfEndOmok::NtfEndOmok(const NtfEndOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfEndOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfEndOmok)
}

inline void NtfEndOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_){0}
  };
}

NtfEndOmok::~NtfEndOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfEndOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfEndOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NtfEndOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfEndOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfEndOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfEndOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfEndOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfEndOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 status = 1;
  if (_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfEndOmok)
  return target;
}

size_t NtfEndOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfEndOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 status = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfEndOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfEndOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfEndOmok::GetClassData() const { return &_class_data_; }


void NtfEndOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfEndOmok*>(&to_msg);
  auto& from = static_cast<const NtfEndOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfEndOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfEndOmok::CopyFrom(const NtfEndOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfEndOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfEndOmok::IsInitialized() const {
  return true;
}

void NtfEndOmok::InternalSwap(NtfEndOmok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfEndOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[25]);
}

// ===================================================================

class NtfMatchTimeout::_Internal {
 public:
};

NtfMatchTimeout::NtfMatchTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfMatchTimeout)
}
NtfMatchTimeout::NtfMatchTimeout(const NtfMatchTimeout& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  NtfMatchTimeout* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfMatchTimeout)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfMatchTimeout::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfMatchTimeout::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NtfMatchTimeout::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[26]);
}

// ===================================================================

class NtfReadyTimeout::_Internal {
 public:
};

NtfReadyTimeout::NtfReadyTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfReadyTimeout)
}
NtfReadyTimeout::NtfReadyTimeout(const NtfReadyTimeout& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  NtfReadyTimeout* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfReadyTimeout)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfReadyTimeout::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfReadyTimeout::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NtfReadyTimeout::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[27]);
}

// ===================================================================

class NtfPutMokTimeout::_Internal {
 public:
};

NtfPutMokTimeout::NtfPutMokTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfPutMokTimeout)
}
NtfPutMokTimeout::NtfPutMokTimeout(const NtfPutMokTimeout& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  NtfPutMokTimeout* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfPutMokTimeout)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfPutMokTimeout::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfPutMokTimeout::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NtfPutMokTimeout::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[28]);
}

// ===================================================================

class NtfStartOmokView::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfStartOmokView>()._impl_._has_bits_);
  static void set_has_blackid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_whiteid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfStartOmokView::NtfStartOmokView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfStartOmokView)
}
NtfStartOmokView::NtfStartOmokView(const NtfStartOmokView& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfStartOmokView* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blackid_){}
    , decltype(_impl_.whiteid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.blackid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blackid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_blackid()) {
    _this->_impl_.blackid_.Set(from._internal_blackid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.whiteid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.whiteid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_whiteid()) {
    _this->_impl_.whiteid_.Set(from._internal_whiteid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfStartOmokView)
}

inline void NtfStartOmokView::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blackid_){}
    , decltype(_impl_.whiteid_){}
  };
  _impl_.blackid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blackid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.whiteid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.whiteid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfStartOmokView::~NtfStartOmokView() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfStartOmokView)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfStartOmokView::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blackid_.Destroy();
  _impl_.whiteid_.Destroy();
}

void NtfStartOmokView::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfStartOmokView::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfStartOmokView)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.blackid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.whiteid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfStartOmokView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string blackId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_blackid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfStartOmokView.blackId"));
        } else
          goto handle_unusual;
        continue;
      // optional string whiteId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_whiteid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfStartOmokView.whiteId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfStartOmokView::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfStartOmokView)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string blackId = 1;
  if (_internal_has_blackid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_blackid().data(), static_cast<int>(this->_internal_blackid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfStartOmokView.blackId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_blackid(), target);
  }

  // optional string whiteId = 2;
  if (_internal_has_whiteid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_whiteid().data(), static_cast<int>(this->_internal_whiteid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfStartOmokView.whiteId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_whiteid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfStartOmokView)
  return target;
}

size_t NtfStartOmokView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfStartOmokView)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string blackId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_blackid());
    }

    // optional string whiteId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_whiteid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfStartOmokView::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfStartOmokView::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfStartOmokView::GetClassData() const { return &_class_data_; }


void NtfStartOmokView::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfStartOmokView*>(&to_msg);
  auto& from = static_cast<const NtfStartOmokView&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfStartOmokView)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_blackid(from._internal_blackid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_whiteid(from._internal_whiteid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfStartOmokView::CopyFrom(const NtfStartOmokView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfStartOmokView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfStartOmokView::IsInitialized() const {
  return true;
}

void NtfStartOmokView::InternalSwap(NtfStartOmokView* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.blackid_, lhs_arena,
      &other->_impl_.blackid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.whiteid_, lhs_arena,
      &other->_impl_.whiteid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfStartOmokView::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace OmokPacket
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqLogin*
Arena::CreateMaybeMessage< ::OmokPacket::ReqLogin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqLogin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResLogin*
Arena::CreateMaybeMessage< ::OmokPacket::ResLogin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResLogin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomEnter*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomEnter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomEnter >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomEnter*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomEnter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomEnter >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomAdmin*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomAdmin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomAdmin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfNewRoomAdmin*
Arena::CreateMaybeMessage< ::OmokPacket::NtfNewRoomAdmin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfNewRoomAdmin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::UserInfo*
Arena::CreateMaybeMessage< ::OmokPacket::UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomUserList*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomUserList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomUserList >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomNewUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomNewUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomNewUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomLeave*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomLeave*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomLeaveUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomLeaveUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomLeaveUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqMatch*
Arena::CreateMaybeMessage< ::OmokPacket::ReqMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResMatch*
Arena::CreateMaybeMessage< ::OmokPacket::ResMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfMatchReq*
Arena::CreateMaybeMessage< ::OmokPacket::NtfMatchReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfMatchReq >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqMatchRes*
Arena::CreateMaybeMessage< ::OmokPacket::ReqMatchRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqMatchRes >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqReadyOmok*
Arena::CreateMaybeMessage< ::OmokPacket::ReqReadyOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqReadyOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResReadyOmok*
Arena::CreateMaybeMessage< ::OmokPacket::ResReadyOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResReadyOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfStartOmok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfStartOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfStartOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::ReqPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::ResPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfEndOmok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfEndOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfEndOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfMatchTimeout*
Arena::CreateMaybeMessage< ::OmokPacket::NtfMatchTimeout >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfMatchTimeout >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfReadyTimeout*
Arena::CreateMaybeMessage< ::OmokPacket::NtfReadyTimeout >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfReadyTimeout >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfPutMokTimeout*
Arena::CreateMaybeMessage< ::OmokPacket::NtfPutMokTimeout >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfPutMokTimeout >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfStartOmokView*
Arena::CreateMaybeMessage< ::OmokPacket::NtfStartOmokView >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfStartOmokView >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
