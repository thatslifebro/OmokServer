// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OmokPacket.proto

#include "OmokPacket.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace OmokPacket {
PROTOBUF_CONSTEXPR ReqLogin::ReqLogin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pw_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqLoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqLoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqLoginDefaultTypeInternal() {}
  union {
    ReqLogin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqLoginDefaultTypeInternal _ReqLogin_default_instance_;
PROTOBUF_CONSTEXPR ResLogin::ResLogin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResLoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResLoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResLoginDefaultTypeInternal() {}
  union {
    ResLogin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResLoginDefaultTypeInternal _ResLogin_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomEnter::ReqRoomEnter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.roomid_)*/0} {}
struct ReqRoomEnterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomEnterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomEnterDefaultTypeInternal() {}
  union {
    ReqRoomEnter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomEnterDefaultTypeInternal _ReqRoomEnter_default_instance_;
PROTOBUF_CONSTEXPR User::User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sessionid_)*/0u} {}
struct UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefaultTypeInternal() {}
  union {
    User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefaultTypeInternal _User_default_instance_;
PROTOBUF_CONSTEXPR ResRoomEnter::ResRoomEnter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomEnterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomEnterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomEnterDefaultTypeInternal() {}
  union {
    ResRoomEnter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomEnterDefaultTypeInternal _ResRoomEnter_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomUserList::NtfRoomUserList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NtfRoomUserListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomUserListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomUserListDefaultTypeInternal() {}
  union {
    NtfRoomUserList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomUserListDefaultTypeInternal _NtfRoomUserList_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomNewUser::NtfRoomNewUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_)*/nullptr} {}
struct NtfRoomNewUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomNewUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomNewUserDefaultTypeInternal() {}
  union {
    NtfRoomNewUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomNewUserDefaultTypeInternal _NtfRoomNewUser_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomLeave::ReqRoomLeave(
    ::_pbi::ConstantInitialized) {}
struct ReqRoomLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomLeaveDefaultTypeInternal() {}
  union {
    ReqRoomLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomLeaveDefaultTypeInternal _ReqRoomLeave_default_instance_;
PROTOBUF_CONSTEXPR ResRoomLeave::ResRoomLeave(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResRoomLeaveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomLeaveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomLeaveDefaultTypeInternal() {}
  union {
    ResRoomLeave _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomLeaveDefaultTypeInternal _ResRoomLeave_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomLeaveUser::NtfRoomLeaveUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_)*/nullptr} {}
struct NtfRoomLeaveUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomLeaveUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomLeaveUserDefaultTypeInternal() {}
  union {
    NtfRoomLeaveUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomLeaveUserDefaultTypeInternal _NtfRoomLeaveUser_default_instance_;
PROTOBUF_CONSTEXPR ReqRoomChat::ReqRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sessionid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqRoomChatDefaultTypeInternal() {}
  union {
    ReqRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqRoomChatDefaultTypeInternal _ReqRoomChat_default_instance_;
PROTOBUF_CONSTEXPR ResRoomChat::ResRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ResRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResRoomChatDefaultTypeInternal() {}
  union {
    ResRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResRoomChatDefaultTypeInternal _ResRoomChat_default_instance_;
PROTOBUF_CONSTEXPR NtfRoomChat::NtfRoomChat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chat_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfRoomChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfRoomChatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfRoomChatDefaultTypeInternal() {}
  union {
    NtfRoomChat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfRoomChatDefaultTypeInternal _NtfRoomChat_default_instance_;
PROTOBUF_CONSTEXPR ReqMatch::ReqMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqMatchDefaultTypeInternal() {}
  union {
    ReqMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqMatchDefaultTypeInternal _ReqMatch_default_instance_;
PROTOBUF_CONSTEXPR ResMatch::ResMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResMatchDefaultTypeInternal() {}
  union {
    ResMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResMatchDefaultTypeInternal _ResMatch_default_instance_;
PROTOBUF_CONSTEXPR NtfMatchUser::NtfMatchUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfMatchUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfMatchUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfMatchUserDefaultTypeInternal() {}
  union {
    NtfMatchUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfMatchUserDefaultTypeInternal _NtfMatchUser_default_instance_;
PROTOBUF_CONSTEXPR ReqReadyOmok::ReqReadyOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReqReadyOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqReadyOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqReadyOmokDefaultTypeInternal() {}
  union {
    ReqReadyOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqReadyOmokDefaultTypeInternal _ReqReadyOmok_default_instance_;
PROTOBUF_CONSTEXPR ResReadyOmok::ResReadyOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResReadyOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResReadyOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResReadyOmokDefaultTypeInternal() {}
  union {
    ResReadyOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResReadyOmokDefaultTypeInternal _ResReadyOmok_default_instance_;
PROTOBUF_CONSTEXPR NtfStartOmok::NtfStartOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.firstuserid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.seconduserid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfStartOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfStartOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfStartOmokDefaultTypeInternal() {}
  union {
    NtfStartOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfStartOmokDefaultTypeInternal _NtfStartOmok_default_instance_;
PROTOBUF_CONSTEXPR ReqPutMok::ReqPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct ReqPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqPutMokDefaultTypeInternal() {}
  union {
    ReqPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqPutMokDefaultTypeInternal _ReqPutMok_default_instance_;
PROTOBUF_CONSTEXPR ResPutMok::ResPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.result_)*/0} {}
struct ResPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResPutMokDefaultTypeInternal() {}
  union {
    ResPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResPutMokDefaultTypeInternal _ResPutMok_default_instance_;
PROTOBUF_CONSTEXPR NtfPutMok::NtfPutMok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct NtfPutMokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfPutMokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfPutMokDefaultTypeInternal() {}
  union {
    NtfPutMok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfPutMokDefaultTypeInternal _NtfPutMok_default_instance_;
PROTOBUF_CONSTEXPR NtfEndOmok::NtfEndOmok(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.winneruserid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NtfEndOmokDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NtfEndOmokDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NtfEndOmokDefaultTypeInternal() {}
  union {
    NtfEndOmok _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NtfEndOmokDefaultTypeInternal _NtfEndOmok_default_instance_;
}  // namespace OmokPacket
static ::_pb::Metadata file_level_metadata_OmokPacket_2eproto[23];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_OmokPacket_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_OmokPacket_2eproto = nullptr;

const uint32_t TableStruct_OmokPacket_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqLogin, _impl_.pw_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResLogin, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomEnter, _impl_.roomid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::User, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::User, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::User, _impl_.sessionid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomEnter, _impl_.result_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomUserList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomUserList, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomNewUser, _impl_.user_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomLeave, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomLeaveUser, _impl_.user_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_.sessionid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqRoomChat, _impl_.chat_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResRoomChat, _impl_.chat_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfRoomChat, _impl_.chat_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqMatch, _impl_.userid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResMatch, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchUser, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfMatchUser, _impl_.userid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqReadyOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqReadyOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqReadyOmok, _impl_.userid_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResReadyOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResReadyOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResReadyOmok, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_.firstuserid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfStartOmok, _impl_.seconduserid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ReqPutMok, _impl_.y_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::ResPutMok, _impl_.result_),
  0,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfPutMok, _impl_.y_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::OmokPacket::NtfEndOmok, _impl_.winneruserid_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::OmokPacket::ReqLogin)},
  { 10, 17, -1, sizeof(::OmokPacket::ResLogin)},
  { 18, 25, -1, sizeof(::OmokPacket::ReqRoomEnter)},
  { 26, 34, -1, sizeof(::OmokPacket::User)},
  { 36, 43, -1, sizeof(::OmokPacket::ResRoomEnter)},
  { 44, -1, -1, sizeof(::OmokPacket::NtfRoomUserList)},
  { 51, 58, -1, sizeof(::OmokPacket::NtfRoomNewUser)},
  { 59, -1, -1, sizeof(::OmokPacket::ReqRoomLeave)},
  { 65, 72, -1, sizeof(::OmokPacket::ResRoomLeave)},
  { 73, 80, -1, sizeof(::OmokPacket::NtfRoomLeaveUser)},
  { 81, 89, -1, sizeof(::OmokPacket::ReqRoomChat)},
  { 91, 99, -1, sizeof(::OmokPacket::ResRoomChat)},
  { 101, 109, -1, sizeof(::OmokPacket::NtfRoomChat)},
  { 111, 118, -1, sizeof(::OmokPacket::ReqMatch)},
  { 119, 126, -1, sizeof(::OmokPacket::ResMatch)},
  { 127, 134, -1, sizeof(::OmokPacket::NtfMatchUser)},
  { 135, 142, -1, sizeof(::OmokPacket::ReqReadyOmok)},
  { 143, 150, -1, sizeof(::OmokPacket::ResReadyOmok)},
  { 151, 159, -1, sizeof(::OmokPacket::NtfStartOmok)},
  { 161, 170, -1, sizeof(::OmokPacket::ReqPutMok)},
  { 173, 180, -1, sizeof(::OmokPacket::ResPutMok)},
  { 181, 190, -1, sizeof(::OmokPacket::NtfPutMok)},
  { 193, 200, -1, sizeof(::OmokPacket::NtfEndOmok)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::OmokPacket::_ReqLogin_default_instance_._instance,
  &::OmokPacket::_ResLogin_default_instance_._instance,
  &::OmokPacket::_ReqRoomEnter_default_instance_._instance,
  &::OmokPacket::_User_default_instance_._instance,
  &::OmokPacket::_ResRoomEnter_default_instance_._instance,
  &::OmokPacket::_NtfRoomUserList_default_instance_._instance,
  &::OmokPacket::_NtfRoomNewUser_default_instance_._instance,
  &::OmokPacket::_ReqRoomLeave_default_instance_._instance,
  &::OmokPacket::_ResRoomLeave_default_instance_._instance,
  &::OmokPacket::_NtfRoomLeaveUser_default_instance_._instance,
  &::OmokPacket::_ReqRoomChat_default_instance_._instance,
  &::OmokPacket::_ResRoomChat_default_instance_._instance,
  &::OmokPacket::_NtfRoomChat_default_instance_._instance,
  &::OmokPacket::_ReqMatch_default_instance_._instance,
  &::OmokPacket::_ResMatch_default_instance_._instance,
  &::OmokPacket::_NtfMatchUser_default_instance_._instance,
  &::OmokPacket::_ReqReadyOmok_default_instance_._instance,
  &::OmokPacket::_ResReadyOmok_default_instance_._instance,
  &::OmokPacket::_NtfStartOmok_default_instance_._instance,
  &::OmokPacket::_ReqPutMok_default_instance_._instance,
  &::OmokPacket::_ResPutMok_default_instance_._instance,
  &::OmokPacket::_NtfPutMok_default_instance_._instance,
  &::OmokPacket::_NtfEndOmok_default_instance_._instance,
};

const char descriptor_table_protodef_OmokPacket_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020OmokPacket.proto\022\nOmokPacket\"B\n\010ReqLog"
  "in\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\017\n\002pw\030\002 \001(\tH\001\210\001\001"
  "B\t\n\007_userIdB\005\n\003_pw\"*\n\010ResLogin\022\023\n\006result"
  "\030\001 \001(\005H\000\210\001\001B\t\n\007_result\".\n\014ReqRoomEnter\022\023"
  "\n\006roomId\030\001 \001(\005H\000\210\001\001B\t\n\007_roomId\"L\n\004User\022\023"
  "\n\006userId\030\001 \001(\tH\000\210\001\001\022\026\n\tsessionId\030\002 \001(\rH\001"
  "\210\001\001B\t\n\007_userIdB\014\n\n_sessionId\".\n\014ResRoomE"
  "nter\022\023\n\006result\030\001 \001(\005H\000\210\001\001B\t\n\007_result\"1\n\017"
  "NtfRoomUserList\022\036\n\004user\030\001 \003(\0132\020.OmokPack"
  "et.User\">\n\016NtfRoomNewUser\022#\n\004user\030\001 \001(\0132"
  "\020.OmokPacket.UserH\000\210\001\001B\007\n\005_user\"\016\n\014ReqRo"
  "omLeave\".\n\014ResRoomLeave\022\023\n\006result\030\001 \001(\005H"
  "\000\210\001\001B\t\n\007_result\"@\n\020NtfRoomLeaveUser\022#\n\004u"
  "ser\030\001 \001(\0132\020.OmokPacket.UserH\000\210\001\001B\007\n\005_use"
  "r\"O\n\013ReqRoomChat\022\026\n\tsessionId\030\001 \001(\tH\000\210\001\001"
  "\022\021\n\004chat\030\002 \001(\tH\001\210\001\001B\014\n\n_sessionIdB\007\n\005_ch"
  "at\"I\n\013ResRoomChat\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\021"
  "\n\004chat\030\002 \001(\tH\001\210\001\001B\t\n\007_userIdB\007\n\005_chat\"I\n"
  "\013NtfRoomChat\022\023\n\006userId\030\001 \001(\tH\000\210\001\001\022\021\n\004cha"
  "t\030\002 \001(\tH\001\210\001\001B\t\n\007_userIdB\007\n\005_chat\"*\n\010ReqM"
  "atch\022\023\n\006userId\030\001 \001(\tH\000\210\001\001B\t\n\007_userId\"*\n\010"
  "ResMatch\022\023\n\006result\030\001 \001(\005H\000\210\001\001B\t\n\007_result"
  "\".\n\014NtfMatchUser\022\023\n\006userId\030\001 \001(\tH\000\210\001\001B\t\n"
  "\007_userId\".\n\014ReqReadyOmok\022\023\n\006userId\030\001 \001(\t"
  "H\000\210\001\001B\t\n\007_userId\".\n\014ResReadyOmok\022\023\n\006resu"
  "lt\030\001 \001(\005H\000\210\001\001B\t\n\007_result\"d\n\014NtfStartOmok"
  "\022\030\n\013firstUserId\030\001 \001(\tH\000\210\001\001\022\031\n\014secondUser"
  "Id\030\002 \001(\tH\001\210\001\001B\016\n\014_firstUserIdB\017\n\r_second"
  "UserId\"W\n\tReqPutMok\022\023\n\006userId\030\001 \001(\tH\000\210\001\001"
  "\022\016\n\001x\030\002 \001(\005H\001\210\001\001\022\016\n\001y\030\003 \001(\005H\002\210\001\001B\t\n\007_use"
  "rIdB\004\n\002_xB\004\n\002_y\"+\n\tResPutMok\022\023\n\006result\030\001"
  " \001(\005H\000\210\001\001B\t\n\007_result\"W\n\tNtfPutMok\022\023\n\006use"
  "rId\030\001 \001(\tH\000\210\001\001\022\016\n\001x\030\002 \001(\005H\001\210\001\001\022\016\n\001y\030\003 \001("
  "\005H\002\210\001\001B\t\n\007_userIdB\004\n\002_xB\004\n\002_y\"8\n\nNtfEndO"
  "mok\022\031\n\014winnerUserId\030\001 \001(\tH\000\210\001\001B\017\n\r_winne"
  "rUserIdb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_OmokPacket_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_OmokPacket_2eproto = {
    false, false, 1415, descriptor_table_protodef_OmokPacket_2eproto,
    "OmokPacket.proto",
    &descriptor_table_OmokPacket_2eproto_once, nullptr, 0, 23,
    schemas, file_default_instances, TableStruct_OmokPacket_2eproto::offsets,
    file_level_metadata_OmokPacket_2eproto, file_level_enum_descriptors_OmokPacket_2eproto,
    file_level_service_descriptors_OmokPacket_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_OmokPacket_2eproto_getter() {
  return &descriptor_table_OmokPacket_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_OmokPacket_2eproto(&descriptor_table_OmokPacket_2eproto);
namespace OmokPacket {

// ===================================================================

class ReqLogin::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqLogin>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReqLogin::ReqLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqLogin)
}
ReqLogin::ReqLogin(const ReqLogin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqLogin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.pw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pw_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pw_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pw()) {
    _this->_impl_.pw_.Set(from._internal_pw(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqLogin)
}

inline void ReqLogin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.pw_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pw_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pw_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqLogin::~ReqLogin() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqLogin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqLogin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
  _impl_.pw_.Destroy();
}

void ReqLogin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqLogin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqLogin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pw_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqLogin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqLogin.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional string pw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pw();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqLogin.pw"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqLogin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqLogin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqLogin.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional string pw = 2;
  if (_internal_has_pw()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pw().data(), static_cast<int>(this->_internal_pw().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqLogin.pw");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqLogin)
  return target;
}

size_t ReqLogin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqLogin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional string pw = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pw());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqLogin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqLogin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqLogin::GetClassData() const { return &_class_data_; }


void ReqLogin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqLogin*>(&to_msg);
  auto& from = static_cast<const ReqLogin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqLogin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pw(from._internal_pw());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqLogin::CopyFrom(const ReqLogin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqLogin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqLogin::IsInitialized() const {
  return true;
}

void ReqLogin::InternalSwap(ReqLogin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pw_, lhs_arena,
      &other->_impl_.pw_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqLogin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[0]);
}

// ===================================================================

class ResLogin::_Internal {
 public:
  using HasBits = decltype(std::declval<ResLogin>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResLogin::ResLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResLogin)
}
ResLogin::ResLogin(const ResLogin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResLogin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResLogin)
}

inline void ResLogin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResLogin::~ResLogin() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResLogin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResLogin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResLogin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResLogin::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResLogin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResLogin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResLogin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResLogin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResLogin)
  return target;
}

size_t ResLogin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResLogin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResLogin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResLogin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResLogin::GetClassData() const { return &_class_data_; }


void ResLogin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResLogin*>(&to_msg);
  auto& from = static_cast<const ResLogin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResLogin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResLogin::CopyFrom(const ResLogin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResLogin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResLogin::IsInitialized() const {
  return true;
}

void ResLogin::InternalSwap(ResLogin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResLogin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[1]);
}

// ===================================================================

class ReqRoomEnter::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqRoomEnter>()._impl_._has_bits_);
  static void set_has_roomid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqRoomEnter::ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomEnter)
}
ReqRoomEnter::ReqRoomEnter(const ReqRoomEnter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqRoomEnter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roomid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.roomid_ = from._impl_.roomid_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomEnter)
}

inline void ReqRoomEnter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.roomid_){0}
  };
}

ReqRoomEnter::~ReqRoomEnter() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqRoomEnter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqRoomEnter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReqRoomEnter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqRoomEnter::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqRoomEnter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.roomid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqRoomEnter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 roomId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_roomid(&has_bits);
          _impl_.roomid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqRoomEnter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqRoomEnter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 roomId = 1;
  if (_internal_has_roomid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_roomid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqRoomEnter)
  return target;
}

size_t ReqRoomEnter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqRoomEnter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 roomId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roomid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomEnter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqRoomEnter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomEnter::GetClassData() const { return &_class_data_; }


void ReqRoomEnter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqRoomEnter*>(&to_msg);
  auto& from = static_cast<const ReqRoomEnter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqRoomEnter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_roomid()) {
    _this->_internal_set_roomid(from._internal_roomid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqRoomEnter::CopyFrom(const ReqRoomEnter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqRoomEnter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoomEnter::IsInitialized() const {
  return true;
}

void ReqRoomEnter::InternalSwap(ReqRoomEnter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.roomid_, other->_impl_.roomid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomEnter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[2]);
}

// ===================================================================

class User::_Internal {
 public:
  using HasBits = decltype(std::declval<User>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

User::User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.User)
}
User::User(const User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.sessionid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.sessionid_ = from._impl_.sessionid_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.User)
}

inline void User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.sessionid_){0u}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

User::~User() {
  // @@protoc_insertion_point(destructor:OmokPacket.User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void User::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_.sessionid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.User.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sessionId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sessionid(&has_bits);
          _impl_.sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.User.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional uint32 sessionId = 2;
  if (_internal_has_sessionid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sessionid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.User)
  return target;
}

size_t User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional uint32 sessionId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sessionid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*User::GetClassData() const { return &_class_data_; }


void User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<User*>(&to_msg);
  auto& from = static_cast<const User&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sessionid_ = from._impl_.sessionid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void User::CopyFrom(const User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  return true;
}

void User::InternalSwap(User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  swap(_impl_.sessionid_, other->_impl_.sessionid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata User::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[3]);
}

// ===================================================================

class ResRoomEnter::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomEnter>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomEnter::ResRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomEnter)
}
ResRoomEnter::ResRoomEnter(const ResRoomEnter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomEnter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomEnter)
}

inline void ResRoomEnter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResRoomEnter::~ResRoomEnter() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomEnter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomEnter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResRoomEnter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomEnter::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomEnter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomEnter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomEnter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomEnter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomEnter)
  return target;
}

size_t ResRoomEnter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomEnter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomEnter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomEnter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomEnter::GetClassData() const { return &_class_data_; }


void ResRoomEnter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomEnter*>(&to_msg);
  auto& from = static_cast<const ResRoomEnter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomEnter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomEnter::CopyFrom(const ResRoomEnter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomEnter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomEnter::IsInitialized() const {
  return true;
}

void ResRoomEnter::InternalSwap(ResRoomEnter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomEnter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[4]);
}

// ===================================================================

class NtfRoomUserList::_Internal {
 public:
};

NtfRoomUserList::NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomUserList)
}
NtfRoomUserList::NtfRoomUserList(const NtfRoomUserList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomUserList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){from._impl_.user_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomUserList)
}

inline void NtfRoomUserList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NtfRoomUserList::~NtfRoomUserList() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomUserList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomUserList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.~RepeatedPtrField();
}

void NtfRoomUserList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomUserList::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomUserList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomUserList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .OmokPacket.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomUserList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomUserList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .OmokPacket.User user = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_user_size()); i < n; i++) {
    const auto& repfield = this->_internal_user(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomUserList)
  return target;
}

size_t NtfRoomUserList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomUserList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .OmokPacket.User user = 1;
  total_size += 1UL * this->_internal_user_size();
  for (const auto& msg : this->_impl_.user_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomUserList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomUserList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomUserList::GetClassData() const { return &_class_data_; }


void NtfRoomUserList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomUserList*>(&to_msg);
  auto& from = static_cast<const NtfRoomUserList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomUserList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_.MergeFrom(from._impl_.user_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomUserList::CopyFrom(const NtfRoomUserList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomUserList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomUserList::IsInitialized() const {
  return true;
}

void NtfRoomUserList::InternalSwap(NtfRoomUserList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.user_.InternalSwap(&other->_impl_.user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomUserList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[5]);
}

// ===================================================================

class NtfRoomNewUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomNewUser>()._impl_._has_bits_);
  static const ::OmokPacket::User& user(const NtfRoomNewUser* msg);
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::User&
NtfRoomNewUser::_Internal::user(const NtfRoomNewUser* msg) {
  return *msg->_impl_.user_;
}
NtfRoomNewUser::NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomNewUser)
}
NtfRoomNewUser::NtfRoomNewUser(const NtfRoomNewUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomNewUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    _this->_impl_.user_ = new ::OmokPacket::User(*from._impl_.user_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomNewUser)
}

inline void NtfRoomNewUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){nullptr}
  };
}

NtfRoomNewUser::~NtfRoomNewUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomNewUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomNewUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.user_;
}

void NtfRoomNewUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomNewUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomNewUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.user_ != nullptr);
    _impl_.user_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomNewUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomNewUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomNewUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.User user = 1;
  if (_internal_has_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::user(this),
        _Internal::user(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomNewUser)
  return target;
}

size_t NtfRoomNewUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomNewUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .OmokPacket.User user = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomNewUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomNewUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomNewUser::GetClassData() const { return &_class_data_; }


void NtfRoomNewUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomNewUser*>(&to_msg);
  auto& from = static_cast<const NtfRoomNewUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomNewUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _this->_internal_mutable_user()->::OmokPacket::User::MergeFrom(
        from._internal_user());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomNewUser::CopyFrom(const NtfRoomNewUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomNewUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomNewUser::IsInitialized() const {
  return true;
}

void NtfRoomNewUser::InternalSwap(NtfRoomNewUser* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.user_, other->_impl_.user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomNewUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[6]);
}

// ===================================================================

class ReqRoomLeave::_Internal {
 public:
};

ReqRoomLeave::ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomLeave)
}
ReqRoomLeave::ReqRoomLeave(const ReqRoomLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ReqRoomLeave* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomLeave)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomLeave::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[7]);
}

// ===================================================================

class ResRoomLeave::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomLeave>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResRoomLeave::ResRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomLeave)
}
ResRoomLeave::ResRoomLeave(const ResRoomLeave& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomLeave* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomLeave)
}

inline void ResRoomLeave::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResRoomLeave::~ResRoomLeave() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomLeave)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomLeave::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResRoomLeave::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomLeave::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomLeave)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomLeave::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomLeave::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomLeave)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomLeave)
  return target;
}

size_t ResRoomLeave::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomLeave)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomLeave::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomLeave::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomLeave::GetClassData() const { return &_class_data_; }


void ResRoomLeave::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomLeave*>(&to_msg);
  auto& from = static_cast<const ResRoomLeave&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomLeave)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomLeave::CopyFrom(const ResRoomLeave& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomLeave)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomLeave::IsInitialized() const {
  return true;
}

void ResRoomLeave::InternalSwap(ResRoomLeave* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomLeave::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[8]);
}

// ===================================================================

class NtfRoomLeaveUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomLeaveUser>()._impl_._has_bits_);
  static const ::OmokPacket::User& user(const NtfRoomLeaveUser* msg);
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::OmokPacket::User&
NtfRoomLeaveUser::_Internal::user(const NtfRoomLeaveUser* msg) {
  return *msg->_impl_.user_;
}
NtfRoomLeaveUser::NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomLeaveUser)
}
NtfRoomLeaveUser::NtfRoomLeaveUser(const NtfRoomLeaveUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomLeaveUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    _this->_impl_.user_ = new ::OmokPacket::User(*from._impl_.user_);
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomLeaveUser)
}

inline void NtfRoomLeaveUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_){nullptr}
  };
}

NtfRoomLeaveUser::~NtfRoomLeaveUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomLeaveUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomLeaveUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.user_;
}

void NtfRoomLeaveUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomLeaveUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomLeaveUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.user_ != nullptr);
    _impl_.user_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomLeaveUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .OmokPacket.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomLeaveUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomLeaveUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .OmokPacket.User user = 1;
  if (_internal_has_user()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::user(this),
        _Internal::user(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomLeaveUser)
  return target;
}

size_t NtfRoomLeaveUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomLeaveUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .OmokPacket.User user = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomLeaveUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomLeaveUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomLeaveUser::GetClassData() const { return &_class_data_; }


void NtfRoomLeaveUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomLeaveUser*>(&to_msg);
  auto& from = static_cast<const NtfRoomLeaveUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomLeaveUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _this->_internal_mutable_user()->::OmokPacket::User::MergeFrom(
        from._internal_user());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomLeaveUser::CopyFrom(const NtfRoomLeaveUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomLeaveUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomLeaveUser::IsInitialized() const {
  return true;
}

void NtfRoomLeaveUser::InternalSwap(NtfRoomLeaveUser* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.user_, other->_impl_.user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomLeaveUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[9]);
}

// ===================================================================

class ReqRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqRoomChat>()._impl_._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ReqRoomChat::ReqRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqRoomChat)
}
ReqRoomChat::ReqRoomChat(const ReqRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sessionid_){}
    , decltype(_impl_.chat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sessionid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sessionid()) {
    _this->_impl_.sessionid_.Set(from._internal_sessionid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqRoomChat)
}

inline void ReqRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sessionid_){}
    , decltype(_impl_.chat_){}
  };
  _impl_.sessionid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqRoomChat::~ReqRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sessionid_.Destroy();
  _impl_.chat_.Destroy();
}

void ReqRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sessionid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.chat_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sessionId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sessionid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqRoomChat.sessionId"));
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string sessionId = 1;
  if (_internal_has_sessionid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sessionid().data(), static_cast<int>(this->_internal_sessionid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqRoomChat.sessionId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sessionid(), target);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqRoomChat)
  return target;
}

size_t ReqRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string sessionId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sessionid());
    }

    // optional string chat = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqRoomChat::GetClassData() const { return &_class_data_; }


void ReqRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqRoomChat*>(&to_msg);
  auto& from = static_cast<const ReqRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sessionid(from._internal_sessionid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_chat(from._internal_chat());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqRoomChat::CopyFrom(const ReqRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqRoomChat::IsInitialized() const {
  return true;
}

void ReqRoomChat::InternalSwap(ReqRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sessionid_, lhs_arena,
      &other->_impl_.sessionid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[10]);
}

// ===================================================================

class ResRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<ResRoomChat>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResRoomChat::ResRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResRoomChat)
}
ResRoomChat::ResRoomChat(const ResRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResRoomChat)
}

inline void ResRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chat_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResRoomChat::~ResRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
  _impl_.chat_.Destroy();
}

void ResRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.chat_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ResRoomChat.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ResRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ResRoomChat.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ResRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResRoomChat)
  return target;
}

size_t ResRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional string chat = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResRoomChat::GetClassData() const { return &_class_data_; }


void ResRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResRoomChat*>(&to_msg);
  auto& from = static_cast<const ResRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_chat(from._internal_chat());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResRoomChat::CopyFrom(const ResRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResRoomChat::IsInitialized() const {
  return true;
}

void ResRoomChat::InternalSwap(ResRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ResRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[11]);
}

// ===================================================================

class NtfRoomChat::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfRoomChat>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfRoomChat::NtfRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfRoomChat)
}
NtfRoomChat::NtfRoomChat(const NtfRoomChat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfRoomChat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chat_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chat()) {
    _this->_impl_.chat_.Set(from._internal_chat(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfRoomChat)
}

inline void NtfRoomChat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chat_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chat_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chat_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfRoomChat::~NtfRoomChat() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfRoomChat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfRoomChat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
  _impl_.chat_.Destroy();
}

void NtfRoomChat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfRoomChat::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfRoomChat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.chat_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfRoomChat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomChat.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional string chat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chat();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfRoomChat.chat"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfRoomChat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfRoomChat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomChat.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional string chat = 2;
  if (_internal_has_chat()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chat().data(), static_cast<int>(this->_internal_chat().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfRoomChat.chat");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfRoomChat)
  return target;
}

size_t NtfRoomChat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfRoomChat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional string chat = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chat());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfRoomChat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfRoomChat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfRoomChat::GetClassData() const { return &_class_data_; }


void NtfRoomChat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfRoomChat*>(&to_msg);
  auto& from = static_cast<const NtfRoomChat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfRoomChat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_chat(from._internal_chat());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfRoomChat::CopyFrom(const NtfRoomChat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfRoomChat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfRoomChat::IsInitialized() const {
  return true;
}

void NtfRoomChat::InternalSwap(NtfRoomChat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chat_, lhs_arena,
      &other->_impl_.chat_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfRoomChat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[12]);
}

// ===================================================================

class ReqMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqMatch>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqMatch::ReqMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqMatch)
}
ReqMatch::ReqMatch(const ReqMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqMatch)
}

inline void ReqMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqMatch::~ReqMatch() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void ReqMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqMatch.userId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqMatch.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqMatch)
  return target;
}

size_t ReqMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string userId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqMatch::GetClassData() const { return &_class_data_; }


void ReqMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqMatch*>(&to_msg);
  auto& from = static_cast<const ReqMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userid()) {
    _this->_internal_set_userid(from._internal_userid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqMatch::CopyFrom(const ReqMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqMatch::IsInitialized() const {
  return true;
}

void ReqMatch::InternalSwap(ReqMatch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[13]);
}

// ===================================================================

class ResMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ResMatch>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResMatch::ResMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResMatch)
}
ResMatch::ResMatch(const ResMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResMatch)
}

inline void ResMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResMatch::~ResMatch() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResMatch)
  return target;
}

size_t ResMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResMatch::GetClassData() const { return &_class_data_; }


void ResMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResMatch*>(&to_msg);
  auto& from = static_cast<const ResMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResMatch::CopyFrom(const ResMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResMatch::IsInitialized() const {
  return true;
}

void ResMatch::InternalSwap(ResMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[14]);
}

// ===================================================================

class NtfMatchUser::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfMatchUser>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfMatchUser::NtfMatchUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfMatchUser)
}
NtfMatchUser::NtfMatchUser(const NtfMatchUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfMatchUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfMatchUser)
}

inline void NtfMatchUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfMatchUser::~NtfMatchUser() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfMatchUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfMatchUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void NtfMatchUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfMatchUser::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfMatchUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfMatchUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfMatchUser.userId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfMatchUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfMatchUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfMatchUser.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfMatchUser)
  return target;
}

size_t NtfMatchUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfMatchUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string userId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfMatchUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfMatchUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfMatchUser::GetClassData() const { return &_class_data_; }


void NtfMatchUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfMatchUser*>(&to_msg);
  auto& from = static_cast<const NtfMatchUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfMatchUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userid()) {
    _this->_internal_set_userid(from._internal_userid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfMatchUser::CopyFrom(const NtfMatchUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfMatchUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfMatchUser::IsInitialized() const {
  return true;
}

void NtfMatchUser::InternalSwap(NtfMatchUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfMatchUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[15]);
}

// ===================================================================

class ReqReadyOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqReadyOmok>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReqReadyOmok::ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqReadyOmok)
}
ReqReadyOmok::ReqReadyOmok(const ReqReadyOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqReadyOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqReadyOmok)
}

inline void ReqReadyOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqReadyOmok::~ReqReadyOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqReadyOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqReadyOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void ReqReadyOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqReadyOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqReadyOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqReadyOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqReadyOmok.userId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqReadyOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqReadyOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqReadyOmok.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqReadyOmok)
  return target;
}

size_t ReqReadyOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqReadyOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string userId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqReadyOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqReadyOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqReadyOmok::GetClassData() const { return &_class_data_; }


void ReqReadyOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqReadyOmok*>(&to_msg);
  auto& from = static_cast<const ReqReadyOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqReadyOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_userid()) {
    _this->_internal_set_userid(from._internal_userid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqReadyOmok::CopyFrom(const ReqReadyOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqReadyOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqReadyOmok::IsInitialized() const {
  return true;
}

void ReqReadyOmok::InternalSwap(ReqReadyOmok* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqReadyOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[16]);
}

// ===================================================================

class ResReadyOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<ResReadyOmok>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResReadyOmok::ResReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResReadyOmok)
}
ResReadyOmok::ResReadyOmok(const ResReadyOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResReadyOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResReadyOmok)
}

inline void ResReadyOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResReadyOmok::~ResReadyOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResReadyOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResReadyOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResReadyOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResReadyOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResReadyOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResReadyOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResReadyOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResReadyOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResReadyOmok)
  return target;
}

size_t ResReadyOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResReadyOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResReadyOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResReadyOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResReadyOmok::GetClassData() const { return &_class_data_; }


void ResReadyOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResReadyOmok*>(&to_msg);
  auto& from = static_cast<const ResReadyOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResReadyOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResReadyOmok::CopyFrom(const ResReadyOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResReadyOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResReadyOmok::IsInitialized() const {
  return true;
}

void ResReadyOmok::InternalSwap(ResReadyOmok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResReadyOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[17]);
}

// ===================================================================

class NtfStartOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfStartOmok>()._impl_._has_bits_);
  static void set_has_firstuserid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seconduserid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NtfStartOmok::NtfStartOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfStartOmok)
}
NtfStartOmok::NtfStartOmok(const NtfStartOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfStartOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.firstuserid_){}
    , decltype(_impl_.seconduserid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.firstuserid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firstuserid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_firstuserid()) {
    _this->_impl_.firstuserid_.Set(from._internal_firstuserid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.seconduserid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.seconduserid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_seconduserid()) {
    _this->_impl_.seconduserid_.Set(from._internal_seconduserid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfStartOmok)
}

inline void NtfStartOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.firstuserid_){}
    , decltype(_impl_.seconduserid_){}
  };
  _impl_.firstuserid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firstuserid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.seconduserid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.seconduserid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfStartOmok::~NtfStartOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfStartOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfStartOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.firstuserid_.Destroy();
  _impl_.seconduserid_.Destroy();
}

void NtfStartOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfStartOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfStartOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.firstuserid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.seconduserid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfStartOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string firstUserId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firstuserid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfStartOmok.firstUserId"));
        } else
          goto handle_unusual;
        continue;
      // optional string secondUserId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_seconduserid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfStartOmok.secondUserId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfStartOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfStartOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string firstUserId = 1;
  if (_internal_has_firstuserid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firstuserid().data(), static_cast<int>(this->_internal_firstuserid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfStartOmok.firstUserId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firstuserid(), target);
  }

  // optional string secondUserId = 2;
  if (_internal_has_seconduserid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_seconduserid().data(), static_cast<int>(this->_internal_seconduserid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfStartOmok.secondUserId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_seconduserid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfStartOmok)
  return target;
}

size_t NtfStartOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfStartOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string firstUserId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_firstuserid());
    }

    // optional string secondUserId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_seconduserid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfStartOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfStartOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfStartOmok::GetClassData() const { return &_class_data_; }


void NtfStartOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfStartOmok*>(&to_msg);
  auto& from = static_cast<const NtfStartOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfStartOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_firstuserid(from._internal_firstuserid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_seconduserid(from._internal_seconduserid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfStartOmok::CopyFrom(const NtfStartOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfStartOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfStartOmok::IsInitialized() const {
  return true;
}

void NtfStartOmok::InternalSwap(NtfStartOmok* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.firstuserid_, lhs_arena,
      &other->_impl_.firstuserid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.seconduserid_, lhs_arena,
      &other->_impl_.seconduserid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfStartOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[18]);
}

// ===================================================================

class ReqPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<ReqPutMok>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ReqPutMok::ReqPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ReqPutMok)
}
ReqPutMok::ReqPutMok(const ReqPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ReqPutMok)
}

inline void ReqPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqPutMok::~ReqPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ReqPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void ReqPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ReqPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.ReqPutMok.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ReqPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.ReqPutMok.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional int32 x = 2;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // optional int32 y = 3;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ReqPutMok)
  return target;
}

size_t ReqPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ReqPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional int32 x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqPutMok::GetClassData() const { return &_class_data_; }


void ReqPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqPutMok*>(&to_msg);
  auto& from = static_cast<const ReqPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ReqPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqPutMok::CopyFrom(const ReqPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ReqPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPutMok::IsInitialized() const {
  return true;
}

void ReqPutMok::InternalSwap(ReqPutMok* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReqPutMok, _impl_.y_)
      + sizeof(ReqPutMok::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(ReqPutMok, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[19]);
}

// ===================================================================

class ResPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<ResPutMok>()._impl_._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResPutMok::ResPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.ResPutMok)
}
ResPutMok::ResPutMok(const ResPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:OmokPacket.ResPutMok)
}

inline void ResPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.result_){0}
  };
}

ResPutMok::~ResPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.ResPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.ResPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.ResPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 result = 1;
  if (_internal_has_result()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.ResPutMok)
  return target;
}

size_t ResPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.ResPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 result = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResPutMok::GetClassData() const { return &_class_data_; }


void ResPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResPutMok*>(&to_msg);
  auto& from = static_cast<const ResPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.ResPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResPutMok::CopyFrom(const ResPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.ResPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResPutMok::IsInitialized() const {
  return true;
}

void ResPutMok::InternalSwap(ResPutMok* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.result_, other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[20]);
}

// ===================================================================

class NtfPutMok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfPutMok>()._impl_._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NtfPutMok::NtfPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfPutMok)
}
NtfPutMok::NtfPutMok(const NtfPutMok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfPutMok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfPutMok)
}

inline void NtfPutMok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfPutMok::~NtfPutMok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfPutMok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfPutMok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userid_.Destroy();
}

void NtfPutMok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfPutMok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfPutMok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.userid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfPutMok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfPutMok.userId"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfPutMok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfPutMok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string userId = 1;
  if (_internal_has_userid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userid().data(), static_cast<int>(this->_internal_userid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfPutMok.userId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userid(), target);
  }

  // optional int32 x = 2;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // optional int32 y = 3;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfPutMok)
  return target;
}

size_t NtfPutMok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfPutMok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string userId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userid());
    }

    // optional int32 x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfPutMok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfPutMok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfPutMok::GetClassData() const { return &_class_data_; }


void NtfPutMok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfPutMok*>(&to_msg);
  auto& from = static_cast<const NtfPutMok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfPutMok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfPutMok::CopyFrom(const NtfPutMok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfPutMok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfPutMok::IsInitialized() const {
  return true;
}

void NtfPutMok::InternalSwap(NtfPutMok* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NtfPutMok, _impl_.y_)
      + sizeof(NtfPutMok::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(NtfPutMok, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfPutMok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[21]);
}

// ===================================================================

class NtfEndOmok::_Internal {
 public:
  using HasBits = decltype(std::declval<NtfEndOmok>()._impl_._has_bits_);
  static void set_has_winneruserid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NtfEndOmok::NtfEndOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:OmokPacket.NtfEndOmok)
}
NtfEndOmok::NtfEndOmok(const NtfEndOmok& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NtfEndOmok* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.winneruserid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.winneruserid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.winneruserid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_winneruserid()) {
    _this->_impl_.winneruserid_.Set(from._internal_winneruserid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:OmokPacket.NtfEndOmok)
}

inline void NtfEndOmok::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.winneruserid_){}
  };
  _impl_.winneruserid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.winneruserid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NtfEndOmok::~NtfEndOmok() {
  // @@protoc_insertion_point(destructor:OmokPacket.NtfEndOmok)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NtfEndOmok::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.winneruserid_.Destroy();
}

void NtfEndOmok::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NtfEndOmok::Clear() {
// @@protoc_insertion_point(message_clear_start:OmokPacket.NtfEndOmok)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.winneruserid_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NtfEndOmok::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string winnerUserId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_winneruserid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "OmokPacket.NtfEndOmok.winnerUserId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NtfEndOmok::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:OmokPacket.NtfEndOmok)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string winnerUserId = 1;
  if (_internal_has_winneruserid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_winneruserid().data(), static_cast<int>(this->_internal_winneruserid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "OmokPacket.NtfEndOmok.winnerUserId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_winneruserid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OmokPacket.NtfEndOmok)
  return target;
}

size_t NtfEndOmok::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:OmokPacket.NtfEndOmok)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string winnerUserId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_winneruserid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NtfEndOmok::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NtfEndOmok::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NtfEndOmok::GetClassData() const { return &_class_data_; }


void NtfEndOmok::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NtfEndOmok*>(&to_msg);
  auto& from = static_cast<const NtfEndOmok&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:OmokPacket.NtfEndOmok)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_winneruserid()) {
    _this->_internal_set_winneruserid(from._internal_winneruserid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NtfEndOmok::CopyFrom(const NtfEndOmok& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OmokPacket.NtfEndOmok)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfEndOmok::IsInitialized() const {
  return true;
}

void NtfEndOmok::InternalSwap(NtfEndOmok* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.winneruserid_, lhs_arena,
      &other->_impl_.winneruserid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NtfEndOmok::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_OmokPacket_2eproto_getter, &descriptor_table_OmokPacket_2eproto_once,
      file_level_metadata_OmokPacket_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace OmokPacket
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqLogin*
Arena::CreateMaybeMessage< ::OmokPacket::ReqLogin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqLogin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResLogin*
Arena::CreateMaybeMessage< ::OmokPacket::ResLogin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResLogin >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomEnter*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomEnter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomEnter >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::User*
Arena::CreateMaybeMessage< ::OmokPacket::User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::User >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomEnter*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomEnter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomEnter >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomUserList*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomUserList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomUserList >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomNewUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomNewUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomNewUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomLeave*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomLeave*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomLeave >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomLeave >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomLeaveUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomLeaveUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomLeaveUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::ReqRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::ResRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfRoomChat*
Arena::CreateMaybeMessage< ::OmokPacket::NtfRoomChat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfRoomChat >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqMatch*
Arena::CreateMaybeMessage< ::OmokPacket::ReqMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResMatch*
Arena::CreateMaybeMessage< ::OmokPacket::ResMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfMatchUser*
Arena::CreateMaybeMessage< ::OmokPacket::NtfMatchUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfMatchUser >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqReadyOmok*
Arena::CreateMaybeMessage< ::OmokPacket::ReqReadyOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqReadyOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResReadyOmok*
Arena::CreateMaybeMessage< ::OmokPacket::ResReadyOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResReadyOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfStartOmok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfStartOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfStartOmok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ReqPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::ReqPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ReqPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::ResPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::ResPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::ResPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfPutMok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfPutMok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfPutMok >(arena);
}
template<> PROTOBUF_NOINLINE ::OmokPacket::NtfEndOmok*
Arena::CreateMaybeMessage< ::OmokPacket::NtfEndOmok >(Arena* arena) {
  return Arena::CreateMessageInternal< ::OmokPacket::NtfEndOmok >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
