// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OmokPacket.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_OmokPacket_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_OmokPacket_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_OmokPacket_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_OmokPacket_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_OmokPacket_2eproto;
namespace OmokPacket {
class NtfEndOmok;
struct NtfEndOmokDefaultTypeInternal;
extern NtfEndOmokDefaultTypeInternal _NtfEndOmok_default_instance_;
class NtfMatchReq;
struct NtfMatchReqDefaultTypeInternal;
extern NtfMatchReqDefaultTypeInternal _NtfMatchReq_default_instance_;
class NtfMatchTimeout;
struct NtfMatchTimeoutDefaultTypeInternal;
extern NtfMatchTimeoutDefaultTypeInternal _NtfMatchTimeout_default_instance_;
class NtfNewRoomAdmin;
struct NtfNewRoomAdminDefaultTypeInternal;
extern NtfNewRoomAdminDefaultTypeInternal _NtfNewRoomAdmin_default_instance_;
class NtfPutMok;
struct NtfPutMokDefaultTypeInternal;
extern NtfPutMokDefaultTypeInternal _NtfPutMok_default_instance_;
class NtfPutMokTimeout;
struct NtfPutMokTimeoutDefaultTypeInternal;
extern NtfPutMokTimeoutDefaultTypeInternal _NtfPutMokTimeout_default_instance_;
class NtfReadyTimeout;
struct NtfReadyTimeoutDefaultTypeInternal;
extern NtfReadyTimeoutDefaultTypeInternal _NtfReadyTimeout_default_instance_;
class NtfRoomAdmin;
struct NtfRoomAdminDefaultTypeInternal;
extern NtfRoomAdminDefaultTypeInternal _NtfRoomAdmin_default_instance_;
class NtfRoomChat;
struct NtfRoomChatDefaultTypeInternal;
extern NtfRoomChatDefaultTypeInternal _NtfRoomChat_default_instance_;
class NtfRoomLeaveUser;
struct NtfRoomLeaveUserDefaultTypeInternal;
extern NtfRoomLeaveUserDefaultTypeInternal _NtfRoomLeaveUser_default_instance_;
class NtfRoomNewUser;
struct NtfRoomNewUserDefaultTypeInternal;
extern NtfRoomNewUserDefaultTypeInternal _NtfRoomNewUser_default_instance_;
class NtfRoomUserList;
struct NtfRoomUserListDefaultTypeInternal;
extern NtfRoomUserListDefaultTypeInternal _NtfRoomUserList_default_instance_;
class NtfStartOmok;
struct NtfStartOmokDefaultTypeInternal;
extern NtfStartOmokDefaultTypeInternal _NtfStartOmok_default_instance_;
class ReqLogin;
struct ReqLoginDefaultTypeInternal;
extern ReqLoginDefaultTypeInternal _ReqLogin_default_instance_;
class ReqMatch;
struct ReqMatchDefaultTypeInternal;
extern ReqMatchDefaultTypeInternal _ReqMatch_default_instance_;
class ReqMatchRes;
struct ReqMatchResDefaultTypeInternal;
extern ReqMatchResDefaultTypeInternal _ReqMatchRes_default_instance_;
class ReqPutMok;
struct ReqPutMokDefaultTypeInternal;
extern ReqPutMokDefaultTypeInternal _ReqPutMok_default_instance_;
class ReqReadyOmok;
struct ReqReadyOmokDefaultTypeInternal;
extern ReqReadyOmokDefaultTypeInternal _ReqReadyOmok_default_instance_;
class ReqRoomChat;
struct ReqRoomChatDefaultTypeInternal;
extern ReqRoomChatDefaultTypeInternal _ReqRoomChat_default_instance_;
class ReqRoomEnter;
struct ReqRoomEnterDefaultTypeInternal;
extern ReqRoomEnterDefaultTypeInternal _ReqRoomEnter_default_instance_;
class ReqRoomLeave;
struct ReqRoomLeaveDefaultTypeInternal;
extern ReqRoomLeaveDefaultTypeInternal _ReqRoomLeave_default_instance_;
class ResLogin;
struct ResLoginDefaultTypeInternal;
extern ResLoginDefaultTypeInternal _ResLogin_default_instance_;
class ResMatch;
struct ResMatchDefaultTypeInternal;
extern ResMatchDefaultTypeInternal _ResMatch_default_instance_;
class ResPutMok;
struct ResPutMokDefaultTypeInternal;
extern ResPutMokDefaultTypeInternal _ResPutMok_default_instance_;
class ResReadyOmok;
struct ResReadyOmokDefaultTypeInternal;
extern ResReadyOmokDefaultTypeInternal _ResReadyOmok_default_instance_;
class ResRoomChat;
struct ResRoomChatDefaultTypeInternal;
extern ResRoomChatDefaultTypeInternal _ResRoomChat_default_instance_;
class ResRoomEnter;
struct ResRoomEnterDefaultTypeInternal;
extern ResRoomEnterDefaultTypeInternal _ResRoomEnter_default_instance_;
class ResRoomLeave;
struct ResRoomLeaveDefaultTypeInternal;
extern ResRoomLeaveDefaultTypeInternal _ResRoomLeave_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace OmokPacket
PROTOBUF_NAMESPACE_OPEN
template<> ::OmokPacket::NtfEndOmok* Arena::CreateMaybeMessage<::OmokPacket::NtfEndOmok>(Arena*);
template<> ::OmokPacket::NtfMatchReq* Arena::CreateMaybeMessage<::OmokPacket::NtfMatchReq>(Arena*);
template<> ::OmokPacket::NtfMatchTimeout* Arena::CreateMaybeMessage<::OmokPacket::NtfMatchTimeout>(Arena*);
template<> ::OmokPacket::NtfNewRoomAdmin* Arena::CreateMaybeMessage<::OmokPacket::NtfNewRoomAdmin>(Arena*);
template<> ::OmokPacket::NtfPutMok* Arena::CreateMaybeMessage<::OmokPacket::NtfPutMok>(Arena*);
template<> ::OmokPacket::NtfPutMokTimeout* Arena::CreateMaybeMessage<::OmokPacket::NtfPutMokTimeout>(Arena*);
template<> ::OmokPacket::NtfReadyTimeout* Arena::CreateMaybeMessage<::OmokPacket::NtfReadyTimeout>(Arena*);
template<> ::OmokPacket::NtfRoomAdmin* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomAdmin>(Arena*);
template<> ::OmokPacket::NtfRoomChat* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomChat>(Arena*);
template<> ::OmokPacket::NtfRoomLeaveUser* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomLeaveUser>(Arena*);
template<> ::OmokPacket::NtfRoomNewUser* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomNewUser>(Arena*);
template<> ::OmokPacket::NtfRoomUserList* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomUserList>(Arena*);
template<> ::OmokPacket::NtfStartOmok* Arena::CreateMaybeMessage<::OmokPacket::NtfStartOmok>(Arena*);
template<> ::OmokPacket::ReqLogin* Arena::CreateMaybeMessage<::OmokPacket::ReqLogin>(Arena*);
template<> ::OmokPacket::ReqMatch* Arena::CreateMaybeMessage<::OmokPacket::ReqMatch>(Arena*);
template<> ::OmokPacket::ReqMatchRes* Arena::CreateMaybeMessage<::OmokPacket::ReqMatchRes>(Arena*);
template<> ::OmokPacket::ReqPutMok* Arena::CreateMaybeMessage<::OmokPacket::ReqPutMok>(Arena*);
template<> ::OmokPacket::ReqReadyOmok* Arena::CreateMaybeMessage<::OmokPacket::ReqReadyOmok>(Arena*);
template<> ::OmokPacket::ReqRoomChat* Arena::CreateMaybeMessage<::OmokPacket::ReqRoomChat>(Arena*);
template<> ::OmokPacket::ReqRoomEnter* Arena::CreateMaybeMessage<::OmokPacket::ReqRoomEnter>(Arena*);
template<> ::OmokPacket::ReqRoomLeave* Arena::CreateMaybeMessage<::OmokPacket::ReqRoomLeave>(Arena*);
template<> ::OmokPacket::ResLogin* Arena::CreateMaybeMessage<::OmokPacket::ResLogin>(Arena*);
template<> ::OmokPacket::ResMatch* Arena::CreateMaybeMessage<::OmokPacket::ResMatch>(Arena*);
template<> ::OmokPacket::ResPutMok* Arena::CreateMaybeMessage<::OmokPacket::ResPutMok>(Arena*);
template<> ::OmokPacket::ResReadyOmok* Arena::CreateMaybeMessage<::OmokPacket::ResReadyOmok>(Arena*);
template<> ::OmokPacket::ResRoomChat* Arena::CreateMaybeMessage<::OmokPacket::ResRoomChat>(Arena*);
template<> ::OmokPacket::ResRoomEnter* Arena::CreateMaybeMessage<::OmokPacket::ResRoomEnter>(Arena*);
template<> ::OmokPacket::ResRoomLeave* Arena::CreateMaybeMessage<::OmokPacket::ResRoomLeave>(Arena*);
template<> ::OmokPacket::UserInfo* Arena::CreateMaybeMessage<::OmokPacket::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace OmokPacket {

// ===================================================================

class ReqLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqLogin) */ {
 public:
  inline ReqLogin() : ReqLogin(nullptr) {}
  ~ReqLogin() override;
  explicit PROTOBUF_CONSTEXPR ReqLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqLogin(const ReqLogin& from);
  ReqLogin(ReqLogin&& from) noexcept
    : ReqLogin() {
    *this = ::std::move(from);
  }

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqLogin& operator=(ReqLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqLogin* internal_default_instance() {
    return reinterpret_cast<const ReqLogin*>(
               &_ReqLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReqLogin& a, ReqLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqLogin& from) {
    ReqLogin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqLogin";
  }
  protected:
  explicit ReqLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPwFieldNumber = 2,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional string pw = 2;
  bool has_pw() const;
  private:
  bool _internal_has_pw() const;
  public:
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResLogin) */ {
 public:
  inline ResLogin() : ResLogin(nullptr) {}
  ~ResLogin() override;
  explicit PROTOBUF_CONSTEXPR ResLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResLogin(const ResLogin& from);
  ResLogin(ResLogin&& from) noexcept
    : ResLogin() {
    *this = ::std::move(from);
  }

  inline ResLogin& operator=(const ResLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResLogin& operator=(ResLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResLogin* internal_default_instance() {
    return reinterpret_cast<const ResLogin*>(
               &_ResLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResLogin& a, ResLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ResLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResLogin& from) {
    ResLogin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResLogin";
  }
  protected:
  explicit ResLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqRoomEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqRoomEnter) */ {
 public:
  inline ReqRoomEnter() : ReqRoomEnter(nullptr) {}
  ~ReqRoomEnter() override;
  explicit PROTOBUF_CONSTEXPR ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoomEnter(const ReqRoomEnter& from);
  ReqRoomEnter(ReqRoomEnter&& from) noexcept
    : ReqRoomEnter() {
    *this = ::std::move(from);
  }

  inline ReqRoomEnter& operator=(const ReqRoomEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoomEnter& operator=(ReqRoomEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoomEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoomEnter* internal_default_instance() {
    return reinterpret_cast<const ReqRoomEnter*>(
               &_ReqRoomEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReqRoomEnter& a, ReqRoomEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoomEnter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoomEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoomEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoomEnter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoomEnter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoomEnter& from) {
    ReqRoomEnter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoomEnter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqRoomEnter";
  }
  protected:
  explicit ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // optional int32 roomId = 1;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqRoomEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t roomid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResRoomEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResRoomEnter) */ {
 public:
  inline ResRoomEnter() : ResRoomEnter(nullptr) {}
  ~ResRoomEnter() override;
  explicit PROTOBUF_CONSTEXPR ResRoomEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResRoomEnter(const ResRoomEnter& from);
  ResRoomEnter(ResRoomEnter&& from) noexcept
    : ResRoomEnter() {
    *this = ::std::move(from);
  }

  inline ResRoomEnter& operator=(const ResRoomEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResRoomEnter& operator=(ResRoomEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResRoomEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResRoomEnter* internal_default_instance() {
    return reinterpret_cast<const ResRoomEnter*>(
               &_ResRoomEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResRoomEnter& a, ResRoomEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(ResRoomEnter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResRoomEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResRoomEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResRoomEnter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResRoomEnter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResRoomEnter& from) {
    ResRoomEnter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResRoomEnter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResRoomEnter";
  }
  protected:
  explicit ResRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional .OmokPacket.UserInfo userInfo = 2;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::OmokPacket::UserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::OmokPacket::UserInfo* release_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::OmokPacket::UserInfo* userinfo);
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo() const;
  ::OmokPacket::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::OmokPacket::UserInfo* userinfo);
  ::OmokPacket::UserInfo* unsafe_arena_release_userinfo();

  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResRoomEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::OmokPacket::UserInfo* userinfo_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomAdmin final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomAdmin) */ {
 public:
  inline NtfRoomAdmin() : NtfRoomAdmin(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NtfRoomAdmin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomAdmin(const NtfRoomAdmin& from);
  NtfRoomAdmin(NtfRoomAdmin&& from) noexcept
    : NtfRoomAdmin() {
    *this = ::std::move(from);
  }

  inline NtfRoomAdmin& operator=(const NtfRoomAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomAdmin& operator=(NtfRoomAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomAdmin* internal_default_instance() {
    return reinterpret_cast<const NtfRoomAdmin*>(
               &_NtfRoomAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NtfRoomAdmin& a, NtfRoomAdmin& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomAdmin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomAdmin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomAdmin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomAdmin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NtfRoomAdmin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NtfRoomAdmin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomAdmin";
  }
  protected:
  explicit NtfRoomAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomAdmin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfNewRoomAdmin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfNewRoomAdmin) */ {
 public:
  inline NtfNewRoomAdmin() : NtfNewRoomAdmin(nullptr) {}
  ~NtfNewRoomAdmin() override;
  explicit PROTOBUF_CONSTEXPR NtfNewRoomAdmin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfNewRoomAdmin(const NtfNewRoomAdmin& from);
  NtfNewRoomAdmin(NtfNewRoomAdmin&& from) noexcept
    : NtfNewRoomAdmin() {
    *this = ::std::move(from);
  }

  inline NtfNewRoomAdmin& operator=(const NtfNewRoomAdmin& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfNewRoomAdmin& operator=(NtfNewRoomAdmin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfNewRoomAdmin& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfNewRoomAdmin* internal_default_instance() {
    return reinterpret_cast<const NtfNewRoomAdmin*>(
               &_NtfNewRoomAdmin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NtfNewRoomAdmin& a, NtfNewRoomAdmin& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfNewRoomAdmin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfNewRoomAdmin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfNewRoomAdmin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfNewRoomAdmin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfNewRoomAdmin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfNewRoomAdmin& from) {
    NtfNewRoomAdmin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfNewRoomAdmin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfNewRoomAdmin";
  }
  protected:
  explicit NtfNewRoomAdmin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 1,
  };
  // optional .OmokPacket.UserInfo userInfo = 1;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::OmokPacket::UserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::OmokPacket::UserInfo* release_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::OmokPacket::UserInfo* userinfo);
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo() const;
  ::OmokPacket::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::OmokPacket::UserInfo* userinfo);
  ::OmokPacket::UserInfo* unsafe_arena_release_userinfo();

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfNewRoomAdmin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::OmokPacket::UserInfo* userinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserInfo& from) {
    UserInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional int32 sessionId = 2;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  int32_t sessionid() const;
  void set_sessionid(int32_t value);
  private:
  int32_t _internal_sessionid() const;
  void _internal_set_sessionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int32_t sessionid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomUserList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomUserList) */ {
 public:
  inline NtfRoomUserList() : NtfRoomUserList(nullptr) {}
  ~NtfRoomUserList() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomUserList(const NtfRoomUserList& from);
  NtfRoomUserList(NtfRoomUserList&& from) noexcept
    : NtfRoomUserList() {
    *this = ::std::move(from);
  }

  inline NtfRoomUserList& operator=(const NtfRoomUserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomUserList& operator=(NtfRoomUserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomUserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomUserList* internal_default_instance() {
    return reinterpret_cast<const NtfRoomUserList*>(
               &_NtfRoomUserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NtfRoomUserList& a, NtfRoomUserList& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomUserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomUserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomUserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomUserList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomUserList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomUserList& from) {
    NtfRoomUserList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomUserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomUserList";
  }
  protected:
  explicit NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 1,
  };
  // repeated .OmokPacket.UserInfo userInfo = 1;
  int userinfo_size() const;
  private:
  int _internal_userinfo_size() const;
  public:
  void clear_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OmokPacket::UserInfo >*
      mutable_userinfo();
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo(int index) const;
  ::OmokPacket::UserInfo* _internal_add_userinfo();
  public:
  const ::OmokPacket::UserInfo& userinfo(int index) const;
  ::OmokPacket::UserInfo* add_userinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OmokPacket::UserInfo >&
      userinfo() const;

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomUserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OmokPacket::UserInfo > userinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomNewUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomNewUser) */ {
 public:
  inline NtfRoomNewUser() : NtfRoomNewUser(nullptr) {}
  ~NtfRoomNewUser() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomNewUser(const NtfRoomNewUser& from);
  NtfRoomNewUser(NtfRoomNewUser&& from) noexcept
    : NtfRoomNewUser() {
    *this = ::std::move(from);
  }

  inline NtfRoomNewUser& operator=(const NtfRoomNewUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomNewUser& operator=(NtfRoomNewUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomNewUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomNewUser* internal_default_instance() {
    return reinterpret_cast<const NtfRoomNewUser*>(
               &_NtfRoomNewUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NtfRoomNewUser& a, NtfRoomNewUser& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomNewUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomNewUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomNewUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomNewUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomNewUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomNewUser& from) {
    NtfRoomNewUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomNewUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomNewUser";
  }
  protected:
  explicit NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 1,
  };
  // optional .OmokPacket.UserInfo userInfo = 1;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::OmokPacket::UserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::OmokPacket::UserInfo* release_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::OmokPacket::UserInfo* userinfo);
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo() const;
  ::OmokPacket::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::OmokPacket::UserInfo* userinfo);
  ::OmokPacket::UserInfo* unsafe_arena_release_userinfo();

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomNewUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::OmokPacket::UserInfo* userinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqRoomLeave final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.ReqRoomLeave) */ {
 public:
  inline ReqRoomLeave() : ReqRoomLeave(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoomLeave(const ReqRoomLeave& from);
  ReqRoomLeave(ReqRoomLeave&& from) noexcept
    : ReqRoomLeave() {
    *this = ::std::move(from);
  }

  inline ReqRoomLeave& operator=(const ReqRoomLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoomLeave& operator=(ReqRoomLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoomLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoomLeave* internal_default_instance() {
    return reinterpret_cast<const ReqRoomLeave*>(
               &_ReqRoomLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReqRoomLeave& a, ReqRoomLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoomLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoomLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoomLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoomLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqRoomLeave& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqRoomLeave& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqRoomLeave";
  }
  protected:
  explicit ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqRoomLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResRoomLeave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResRoomLeave) */ {
 public:
  inline ResRoomLeave() : ResRoomLeave(nullptr) {}
  ~ResRoomLeave() override;
  explicit PROTOBUF_CONSTEXPR ResRoomLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResRoomLeave(const ResRoomLeave& from);
  ResRoomLeave(ResRoomLeave&& from) noexcept
    : ResRoomLeave() {
    *this = ::std::move(from);
  }

  inline ResRoomLeave& operator=(const ResRoomLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResRoomLeave& operator=(ResRoomLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResRoomLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResRoomLeave* internal_default_instance() {
    return reinterpret_cast<const ResRoomLeave*>(
               &_ResRoomLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResRoomLeave& a, ResRoomLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(ResRoomLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResRoomLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResRoomLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResRoomLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResRoomLeave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResRoomLeave& from) {
    ResRoomLeave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResRoomLeave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResRoomLeave";
  }
  protected:
  explicit ResRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResRoomLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomLeaveUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomLeaveUser) */ {
 public:
  inline NtfRoomLeaveUser() : NtfRoomLeaveUser(nullptr) {}
  ~NtfRoomLeaveUser() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomLeaveUser(const NtfRoomLeaveUser& from);
  NtfRoomLeaveUser(NtfRoomLeaveUser&& from) noexcept
    : NtfRoomLeaveUser() {
    *this = ::std::move(from);
  }

  inline NtfRoomLeaveUser& operator=(const NtfRoomLeaveUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomLeaveUser& operator=(NtfRoomLeaveUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomLeaveUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomLeaveUser* internal_default_instance() {
    return reinterpret_cast<const NtfRoomLeaveUser*>(
               &_NtfRoomLeaveUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NtfRoomLeaveUser& a, NtfRoomLeaveUser& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomLeaveUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomLeaveUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomLeaveUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomLeaveUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomLeaveUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomLeaveUser& from) {
    NtfRoomLeaveUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomLeaveUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomLeaveUser";
  }
  protected:
  explicit NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 1,
  };
  // optional .OmokPacket.UserInfo userInfo = 1;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::OmokPacket::UserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::OmokPacket::UserInfo* release_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::OmokPacket::UserInfo* userinfo);
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo() const;
  ::OmokPacket::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::OmokPacket::UserInfo* userinfo);
  ::OmokPacket::UserInfo* unsafe_arena_release_userinfo();

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomLeaveUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::OmokPacket::UserInfo* userinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqRoomChat) */ {
 public:
  inline ReqRoomChat() : ReqRoomChat(nullptr) {}
  ~ReqRoomChat() override;
  explicit PROTOBUF_CONSTEXPR ReqRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoomChat(const ReqRoomChat& from);
  ReqRoomChat(ReqRoomChat&& from) noexcept
    : ReqRoomChat() {
    *this = ::std::move(from);
  }

  inline ReqRoomChat& operator=(const ReqRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoomChat& operator=(ReqRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoomChat* internal_default_instance() {
    return reinterpret_cast<const ReqRoomChat*>(
               &_ReqRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReqRoomChat& a, ReqRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoomChat& from) {
    ReqRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqRoomChat";
  }
  protected:
  explicit ReqRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 1,
  };
  // optional string chat = 1;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResRoomChat) */ {
 public:
  inline ResRoomChat() : ResRoomChat(nullptr) {}
  ~ResRoomChat() override;
  explicit PROTOBUF_CONSTEXPR ResRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResRoomChat(const ResRoomChat& from);
  ResRoomChat(ResRoomChat&& from) noexcept
    : ResRoomChat() {
    *this = ::std::move(from);
  }

  inline ResRoomChat& operator=(const ResRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResRoomChat& operator=(ResRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResRoomChat* internal_default_instance() {
    return reinterpret_cast<const ResRoomChat*>(
               &_ResRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResRoomChat& a, ResRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ResRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResRoomChat& from) {
    ResRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResRoomChat";
  }
  protected:
  explicit ResRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional string chat = 2;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomChat) */ {
 public:
  inline NtfRoomChat() : NtfRoomChat(nullptr) {}
  ~NtfRoomChat() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomChat(const NtfRoomChat& from);
  NtfRoomChat(NtfRoomChat&& from) noexcept
    : NtfRoomChat() {
    *this = ::std::move(from);
  }

  inline NtfRoomChat& operator=(const NtfRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomChat& operator=(NtfRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomChat* internal_default_instance() {
    return reinterpret_cast<const NtfRoomChat*>(
               &_NtfRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NtfRoomChat& a, NtfRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomChat& from) {
    NtfRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomChat";
  }
  protected:
  explicit NtfRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 2,
    kUserInfoFieldNumber = 1,
  };
  // optional string chat = 2;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // optional .OmokPacket.UserInfo userInfo = 1;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::OmokPacket::UserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::OmokPacket::UserInfo* release_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::OmokPacket::UserInfo* userinfo);
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo() const;
  ::OmokPacket::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::OmokPacket::UserInfo* userinfo);
  ::OmokPacket::UserInfo* unsafe_arena_release_userinfo();

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    ::OmokPacket::UserInfo* userinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqMatch) */ {
 public:
  inline ReqMatch() : ReqMatch(nullptr) {}
  ~ReqMatch() override;
  explicit PROTOBUF_CONSTEXPR ReqMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqMatch(const ReqMatch& from);
  ReqMatch(ReqMatch&& from) noexcept
    : ReqMatch() {
    *this = ::std::move(from);
  }

  inline ReqMatch& operator=(const ReqMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqMatch& operator=(ReqMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqMatch* internal_default_instance() {
    return reinterpret_cast<const ReqMatch*>(
               &_ReqMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReqMatch& a, ReqMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqMatch& from) {
    ReqMatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqMatch";
  }
  protected:
  explicit ReqMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // optional int32 sessionId = 1;
  bool has_sessionid() const;
  private:
  bool _internal_has_sessionid() const;
  public:
  void clear_sessionid();
  int32_t sessionid() const;
  void set_sessionid(int32_t value);
  private:
  int32_t _internal_sessionid() const;
  void _internal_set_sessionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t sessionid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResMatch) */ {
 public:
  inline ResMatch() : ResMatch(nullptr) {}
  ~ResMatch() override;
  explicit PROTOBUF_CONSTEXPR ResMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResMatch(const ResMatch& from);
  ResMatch(ResMatch&& from) noexcept
    : ResMatch() {
    *this = ::std::move(from);
  }

  inline ResMatch& operator=(const ResMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResMatch& operator=(ResMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResMatch* internal_default_instance() {
    return reinterpret_cast<const ResMatch*>(
               &_ResMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ResMatch& a, ResMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ResMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResMatch& from) {
    ResMatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResMatch";
  }
  protected:
  explicit ResMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfMatchReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfMatchReq) */ {
 public:
  inline NtfMatchReq() : NtfMatchReq(nullptr) {}
  ~NtfMatchReq() override;
  explicit PROTOBUF_CONSTEXPR NtfMatchReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfMatchReq(const NtfMatchReq& from);
  NtfMatchReq(NtfMatchReq&& from) noexcept
    : NtfMatchReq() {
    *this = ::std::move(from);
  }

  inline NtfMatchReq& operator=(const NtfMatchReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfMatchReq& operator=(NtfMatchReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfMatchReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfMatchReq* internal_default_instance() {
    return reinterpret_cast<const NtfMatchReq*>(
               &_NtfMatchReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NtfMatchReq& a, NtfMatchReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfMatchReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfMatchReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfMatchReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfMatchReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfMatchReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfMatchReq& from) {
    NtfMatchReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfMatchReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfMatchReq";
  }
  protected:
  explicit NtfMatchReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 1,
  };
  // optional .OmokPacket.UserInfo userInfo = 1;
  bool has_userinfo() const;
  private:
  bool _internal_has_userinfo() const;
  public:
  void clear_userinfo();
  const ::OmokPacket::UserInfo& userinfo() const;
  PROTOBUF_NODISCARD ::OmokPacket::UserInfo* release_userinfo();
  ::OmokPacket::UserInfo* mutable_userinfo();
  void set_allocated_userinfo(::OmokPacket::UserInfo* userinfo);
  private:
  const ::OmokPacket::UserInfo& _internal_userinfo() const;
  ::OmokPacket::UserInfo* _internal_mutable_userinfo();
  public:
  void unsafe_arena_set_allocated_userinfo(
      ::OmokPacket::UserInfo* userinfo);
  ::OmokPacket::UserInfo* unsafe_arena_release_userinfo();

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfMatchReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::OmokPacket::UserInfo* userinfo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqMatchRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqMatchRes) */ {
 public:
  inline ReqMatchRes() : ReqMatchRes(nullptr) {}
  ~ReqMatchRes() override;
  explicit PROTOBUF_CONSTEXPR ReqMatchRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqMatchRes(const ReqMatchRes& from);
  ReqMatchRes(ReqMatchRes&& from) noexcept
    : ReqMatchRes() {
    *this = ::std::move(from);
  }

  inline ReqMatchRes& operator=(const ReqMatchRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqMatchRes& operator=(ReqMatchRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqMatchRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqMatchRes* internal_default_instance() {
    return reinterpret_cast<const ReqMatchRes*>(
               &_ReqMatchRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReqMatchRes& a, ReqMatchRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqMatchRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqMatchRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqMatchRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqMatchRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqMatchRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqMatchRes& from) {
    ReqMatchRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMatchRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqMatchRes";
  }
  protected:
  explicit ReqMatchRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptFieldNumber = 1,
  };
  // optional bool accept = 1;
  bool has_accept() const;
  private:
  bool _internal_has_accept() const;
  public:
  void clear_accept();
  bool accept() const;
  void set_accept(bool value);
  private:
  bool _internal_accept() const;
  void _internal_set_accept(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqMatchRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool accept_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqReadyOmok final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.ReqReadyOmok) */ {
 public:
  inline ReqReadyOmok() : ReqReadyOmok(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqReadyOmok(const ReqReadyOmok& from);
  ReqReadyOmok(ReqReadyOmok&& from) noexcept
    : ReqReadyOmok() {
    *this = ::std::move(from);
  }

  inline ReqReadyOmok& operator=(const ReqReadyOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqReadyOmok& operator=(ReqReadyOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqReadyOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqReadyOmok* internal_default_instance() {
    return reinterpret_cast<const ReqReadyOmok*>(
               &_ReqReadyOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ReqReadyOmok& a, ReqReadyOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqReadyOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqReadyOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqReadyOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqReadyOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqReadyOmok& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqReadyOmok& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqReadyOmok";
  }
  protected:
  explicit ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqReadyOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResReadyOmok final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.ResReadyOmok) */ {
 public:
  inline ResReadyOmok() : ResReadyOmok(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResReadyOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResReadyOmok(const ResReadyOmok& from);
  ResReadyOmok(ResReadyOmok&& from) noexcept
    : ResReadyOmok() {
    *this = ::std::move(from);
  }

  inline ResReadyOmok& operator=(const ResReadyOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResReadyOmok& operator=(ResReadyOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResReadyOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResReadyOmok* internal_default_instance() {
    return reinterpret_cast<const ResReadyOmok*>(
               &_ResReadyOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ResReadyOmok& a, ResReadyOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(ResReadyOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResReadyOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResReadyOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResReadyOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResReadyOmok& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResReadyOmok& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResReadyOmok";
  }
  protected:
  explicit ResReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.ResReadyOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfStartOmok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfStartOmok) */ {
 public:
  inline NtfStartOmok() : NtfStartOmok(nullptr) {}
  ~NtfStartOmok() override;
  explicit PROTOBUF_CONSTEXPR NtfStartOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfStartOmok(const NtfStartOmok& from);
  NtfStartOmok(NtfStartOmok&& from) noexcept
    : NtfStartOmok() {
    *this = ::std::move(from);
  }

  inline NtfStartOmok& operator=(const NtfStartOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfStartOmok& operator=(NtfStartOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfStartOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfStartOmok* internal_default_instance() {
    return reinterpret_cast<const NtfStartOmok*>(
               &_NtfStartOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NtfStartOmok& a, NtfStartOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfStartOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfStartOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfStartOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfStartOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfStartOmok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfStartOmok& from) {
    NtfStartOmok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfStartOmok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfStartOmok";
  }
  protected:
  explicit NtfStartOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMyIdFieldNumber = 2,
    kOpponentIdFieldNumber = 3,
    kBlackFieldNumber = 1,
  };
  // optional string myId = 2;
  bool has_myid() const;
  private:
  bool _internal_has_myid() const;
  public:
  void clear_myid();
  const std::string& myid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_myid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_myid();
  PROTOBUF_NODISCARD std::string* release_myid();
  void set_allocated_myid(std::string* myid);
  private:
  const std::string& _internal_myid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_myid(const std::string& value);
  std::string* _internal_mutable_myid();
  public:

  // optional string opponentId = 3;
  bool has_opponentid() const;
  private:
  bool _internal_has_opponentid() const;
  public:
  void clear_opponentid();
  const std::string& opponentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opponentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opponentid();
  PROTOBUF_NODISCARD std::string* release_opponentid();
  void set_allocated_opponentid(std::string* opponentid);
  private:
  const std::string& _internal_opponentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opponentid(const std::string& value);
  std::string* _internal_mutable_opponentid();
  public:

  // optional bool black = 1;
  bool has_black() const;
  private:
  bool _internal_has_black() const;
  public:
  void clear_black();
  bool black() const;
  void set_black(bool value);
  private:
  bool _internal_black() const;
  void _internal_set_black(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfStartOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr myid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opponentid_;
    bool black_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqPutMok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqPutMok) */ {
 public:
  inline ReqPutMok() : ReqPutMok(nullptr) {}
  ~ReqPutMok() override;
  explicit PROTOBUF_CONSTEXPR ReqPutMok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqPutMok(const ReqPutMok& from);
  ReqPutMok(ReqPutMok&& from) noexcept
    : ReqPutMok() {
    *this = ::std::move(from);
  }

  inline ReqPutMok& operator=(const ReqPutMok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqPutMok& operator=(ReqPutMok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqPutMok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqPutMok* internal_default_instance() {
    return reinterpret_cast<const ReqPutMok*>(
               &_ReqPutMok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ReqPutMok& a, ReqPutMok& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqPutMok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqPutMok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqPutMok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqPutMok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqPutMok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqPutMok& from) {
    ReqPutMok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqPutMok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqPutMok";
  }
  protected:
  explicit ReqPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqPutMok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResPutMok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResPutMok) */ {
 public:
  inline ResPutMok() : ResPutMok(nullptr) {}
  ~ResPutMok() override;
  explicit PROTOBUF_CONSTEXPR ResPutMok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResPutMok(const ResPutMok& from);
  ResPutMok(ResPutMok&& from) noexcept
    : ResPutMok() {
    *this = ::std::move(from);
  }

  inline ResPutMok& operator=(const ResPutMok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResPutMok& operator=(ResPutMok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResPutMok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResPutMok* internal_default_instance() {
    return reinterpret_cast<const ResPutMok*>(
               &_ResPutMok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ResPutMok& a, ResPutMok& b) {
    a.Swap(&b);
  }
  inline void Swap(ResPutMok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResPutMok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResPutMok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResPutMok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResPutMok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResPutMok& from) {
    ResPutMok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResPutMok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResPutMok";
  }
  protected:
  explicit ResPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResPutMok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfPutMok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfPutMok) */ {
 public:
  inline NtfPutMok() : NtfPutMok(nullptr) {}
  ~NtfPutMok() override;
  explicit PROTOBUF_CONSTEXPR NtfPutMok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfPutMok(const NtfPutMok& from);
  NtfPutMok(NtfPutMok&& from) noexcept
    : NtfPutMok() {
    *this = ::std::move(from);
  }

  inline NtfPutMok& operator=(const NtfPutMok& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfPutMok& operator=(NtfPutMok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfPutMok& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfPutMok* internal_default_instance() {
    return reinterpret_cast<const NtfPutMok*>(
               &_NtfPutMok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(NtfPutMok& a, NtfPutMok& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfPutMok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfPutMok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfPutMok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfPutMok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfPutMok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfPutMok& from) {
    NtfPutMok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfPutMok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfPutMok";
  }
  protected:
  explicit NtfPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfPutMok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfEndOmok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfEndOmok) */ {
 public:
  inline NtfEndOmok() : NtfEndOmok(nullptr) {}
  ~NtfEndOmok() override;
  explicit PROTOBUF_CONSTEXPR NtfEndOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfEndOmok(const NtfEndOmok& from);
  NtfEndOmok(NtfEndOmok&& from) noexcept
    : NtfEndOmok() {
    *this = ::std::move(from);
  }

  inline NtfEndOmok& operator=(const NtfEndOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfEndOmok& operator=(NtfEndOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfEndOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfEndOmok* internal_default_instance() {
    return reinterpret_cast<const NtfEndOmok*>(
               &_NtfEndOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(NtfEndOmok& a, NtfEndOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfEndOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfEndOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfEndOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfEndOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfEndOmok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfEndOmok& from) {
    NtfEndOmok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfEndOmok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfEndOmok";
  }
  protected:
  explicit NtfEndOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfEndOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfMatchTimeout final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.NtfMatchTimeout) */ {
 public:
  inline NtfMatchTimeout() : NtfMatchTimeout(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NtfMatchTimeout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfMatchTimeout(const NtfMatchTimeout& from);
  NtfMatchTimeout(NtfMatchTimeout&& from) noexcept
    : NtfMatchTimeout() {
    *this = ::std::move(from);
  }

  inline NtfMatchTimeout& operator=(const NtfMatchTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfMatchTimeout& operator=(NtfMatchTimeout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfMatchTimeout& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfMatchTimeout* internal_default_instance() {
    return reinterpret_cast<const NtfMatchTimeout*>(
               &_NtfMatchTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(NtfMatchTimeout& a, NtfMatchTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfMatchTimeout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfMatchTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfMatchTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfMatchTimeout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NtfMatchTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NtfMatchTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfMatchTimeout";
  }
  protected:
  explicit NtfMatchTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfMatchTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfReadyTimeout final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.NtfReadyTimeout) */ {
 public:
  inline NtfReadyTimeout() : NtfReadyTimeout(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NtfReadyTimeout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfReadyTimeout(const NtfReadyTimeout& from);
  NtfReadyTimeout(NtfReadyTimeout&& from) noexcept
    : NtfReadyTimeout() {
    *this = ::std::move(from);
  }

  inline NtfReadyTimeout& operator=(const NtfReadyTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfReadyTimeout& operator=(NtfReadyTimeout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfReadyTimeout& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfReadyTimeout* internal_default_instance() {
    return reinterpret_cast<const NtfReadyTimeout*>(
               &_NtfReadyTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(NtfReadyTimeout& a, NtfReadyTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfReadyTimeout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfReadyTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfReadyTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfReadyTimeout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NtfReadyTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NtfReadyTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfReadyTimeout";
  }
  protected:
  explicit NtfReadyTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfReadyTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfPutMokTimeout final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OmokPacket.NtfPutMokTimeout) */ {
 public:
  inline NtfPutMokTimeout() : NtfPutMokTimeout(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NtfPutMokTimeout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfPutMokTimeout(const NtfPutMokTimeout& from);
  NtfPutMokTimeout(NtfPutMokTimeout&& from) noexcept
    : NtfPutMokTimeout() {
    *this = ::std::move(from);
  }

  inline NtfPutMokTimeout& operator=(const NtfPutMokTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfPutMokTimeout& operator=(NtfPutMokTimeout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfPutMokTimeout& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfPutMokTimeout* internal_default_instance() {
    return reinterpret_cast<const NtfPutMokTimeout*>(
               &_NtfPutMokTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NtfPutMokTimeout& a, NtfPutMokTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfPutMokTimeout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfPutMokTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfPutMokTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfPutMokTimeout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NtfPutMokTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NtfPutMokTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfPutMokTimeout";
  }
  protected:
  explicit NtfPutMokTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfPutMokTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqLogin

// optional string userId = 1;
inline bool ReqLogin::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqLogin::has_userid() const {
  return _internal_has_userid();
}
inline void ReqLogin::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqLogin::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqLogin.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLogin::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqLogin.userId)
}
inline std::string* ReqLogin::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqLogin.userId)
  return _s;
}
inline const std::string& ReqLogin::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqLogin::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLogin::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLogin::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqLogin.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqLogin::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqLogin.userId)
}

// optional string pw = 2;
inline bool ReqLogin::_internal_has_pw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReqLogin::has_pw() const {
  return _internal_has_pw();
}
inline void ReqLogin::clear_pw() {
  _impl_.pw_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReqLogin::pw() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqLogin.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLogin::set_pw(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pw_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqLogin.pw)
}
inline std::string* ReqLogin::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqLogin.pw)
  return _s;
}
inline const std::string& ReqLogin::_internal_pw() const {
  return _impl_.pw_.Get();
}
inline void ReqLogin::_internal_set_pw(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pw_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLogin::_internal_mutable_pw() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pw_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLogin::release_pw() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqLogin.pw)
  if (!_internal_has_pw()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pw_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqLogin::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pw_.SetAllocated(pw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqLogin.pw)
}

// -------------------------------------------------------------------

// ResLogin

// optional int32 result = 1;
inline bool ResLogin::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResLogin::has_result() const {
  return _internal_has_result();
}
inline void ResLogin::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResLogin::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResLogin::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResLogin.result)
  return _internal_result();
}
inline void ResLogin::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResLogin::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResLogin.result)
}

// -------------------------------------------------------------------

// ReqRoomEnter

// optional int32 roomId = 1;
inline bool ReqRoomEnter::_internal_has_roomid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqRoomEnter::has_roomid() const {
  return _internal_has_roomid();
}
inline void ReqRoomEnter::clear_roomid() {
  _impl_.roomid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ReqRoomEnter::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t ReqRoomEnter::roomid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomEnter.roomId)
  return _internal_roomid();
}
inline void ReqRoomEnter::_internal_set_roomid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.roomid_ = value;
}
inline void ReqRoomEnter::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomEnter.roomId)
}

// -------------------------------------------------------------------

// ResRoomEnter

// optional int32 result = 1;
inline bool ResRoomEnter::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResRoomEnter::has_result() const {
  return _internal_has_result();
}
inline void ResRoomEnter::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ResRoomEnter::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResRoomEnter::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomEnter.result)
  return _internal_result();
}
inline void ResRoomEnter::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void ResRoomEnter::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomEnter.result)
}

// optional .OmokPacket.UserInfo userInfo = 2;
inline bool ResRoomEnter::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool ResRoomEnter::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void ResRoomEnter::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::OmokPacket::UserInfo& ResRoomEnter::_internal_userinfo() const {
  const ::OmokPacket::UserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::OmokPacket::UserInfo&>(
      ::OmokPacket::_UserInfo_default_instance_);
}
inline const ::OmokPacket::UserInfo& ResRoomEnter::userinfo() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomEnter.userInfo)
  return _internal_userinfo();
}
inline void ResRoomEnter::unsafe_arena_set_allocated_userinfo(
    ::OmokPacket::UserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OmokPacket.ResRoomEnter.userInfo)
}
inline ::OmokPacket::UserInfo* ResRoomEnter::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OmokPacket::UserInfo* ResRoomEnter::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:OmokPacket.ResRoomEnter.userInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::OmokPacket::UserInfo* ResRoomEnter::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::OmokPacket::UserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::OmokPacket::UserInfo* ResRoomEnter::mutable_userinfo() {
  ::OmokPacket::UserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ResRoomEnter.userInfo)
  return _msg;
}
inline void ResRoomEnter::set_allocated_userinfo(::OmokPacket::UserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ResRoomEnter.userInfo)
}

// -------------------------------------------------------------------

// NtfRoomAdmin

// -------------------------------------------------------------------

// NtfNewRoomAdmin

// optional .OmokPacket.UserInfo userInfo = 1;
inline bool NtfNewRoomAdmin::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool NtfNewRoomAdmin::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void NtfNewRoomAdmin::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::OmokPacket::UserInfo& NtfNewRoomAdmin::_internal_userinfo() const {
  const ::OmokPacket::UserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::OmokPacket::UserInfo&>(
      ::OmokPacket::_UserInfo_default_instance_);
}
inline const ::OmokPacket::UserInfo& NtfNewRoomAdmin::userinfo() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfNewRoomAdmin.userInfo)
  return _internal_userinfo();
}
inline void NtfNewRoomAdmin::unsafe_arena_set_allocated_userinfo(
    ::OmokPacket::UserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OmokPacket.NtfNewRoomAdmin.userInfo)
}
inline ::OmokPacket::UserInfo* NtfNewRoomAdmin::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OmokPacket::UserInfo* NtfNewRoomAdmin::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfNewRoomAdmin.userInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::OmokPacket::UserInfo* NtfNewRoomAdmin::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::OmokPacket::UserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::OmokPacket::UserInfo* NtfNewRoomAdmin::mutable_userinfo() {
  ::OmokPacket::UserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfNewRoomAdmin.userInfo)
  return _msg;
}
inline void NtfNewRoomAdmin::set_allocated_userinfo(::OmokPacket::UserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfNewRoomAdmin.userInfo)
}

// -------------------------------------------------------------------

// UserInfo

// optional string userId = 1;
inline bool UserInfo::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_userid() const {
  return _internal_has_userid();
}
inline void UserInfo::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.UserInfo.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.UserInfo.userId)
}
inline std::string* UserInfo::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.UserInfo.userId)
  return _s;
}
inline const std::string& UserInfo::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserInfo::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.UserInfo.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.UserInfo.userId)
}

// optional int32 sessionId = 2;
inline bool UserInfo::_internal_has_sessionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void UserInfo::clear_sessionid() {
  _impl_.sessionid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UserInfo::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline int32_t UserInfo::sessionid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.UserInfo.sessionId)
  return _internal_sessionid();
}
inline void UserInfo::_internal_set_sessionid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sessionid_ = value;
}
inline void UserInfo::set_sessionid(int32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:OmokPacket.UserInfo.sessionId)
}

// -------------------------------------------------------------------

// NtfRoomUserList

// repeated .OmokPacket.UserInfo userInfo = 1;
inline int NtfRoomUserList::_internal_userinfo_size() const {
  return _impl_.userinfo_.size();
}
inline int NtfRoomUserList::userinfo_size() const {
  return _internal_userinfo_size();
}
inline void NtfRoomUserList::clear_userinfo() {
  _impl_.userinfo_.Clear();
}
inline ::OmokPacket::UserInfo* NtfRoomUserList::mutable_userinfo(int index) {
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomUserList.userInfo)
  return _impl_.userinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OmokPacket::UserInfo >*
NtfRoomUserList::mutable_userinfo() {
  // @@protoc_insertion_point(field_mutable_list:OmokPacket.NtfRoomUserList.userInfo)
  return &_impl_.userinfo_;
}
inline const ::OmokPacket::UserInfo& NtfRoomUserList::_internal_userinfo(int index) const {
  return _impl_.userinfo_.Get(index);
}
inline const ::OmokPacket::UserInfo& NtfRoomUserList::userinfo(int index) const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomUserList.userInfo)
  return _internal_userinfo(index);
}
inline ::OmokPacket::UserInfo* NtfRoomUserList::_internal_add_userinfo() {
  return _impl_.userinfo_.Add();
}
inline ::OmokPacket::UserInfo* NtfRoomUserList::add_userinfo() {
  ::OmokPacket::UserInfo* _add = _internal_add_userinfo();
  // @@protoc_insertion_point(field_add:OmokPacket.NtfRoomUserList.userInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OmokPacket::UserInfo >&
NtfRoomUserList::userinfo() const {
  // @@protoc_insertion_point(field_list:OmokPacket.NtfRoomUserList.userInfo)
  return _impl_.userinfo_;
}

// -------------------------------------------------------------------

// NtfRoomNewUser

// optional .OmokPacket.UserInfo userInfo = 1;
inline bool NtfRoomNewUser::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool NtfRoomNewUser::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void NtfRoomNewUser::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::OmokPacket::UserInfo& NtfRoomNewUser::_internal_userinfo() const {
  const ::OmokPacket::UserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::OmokPacket::UserInfo&>(
      ::OmokPacket::_UserInfo_default_instance_);
}
inline const ::OmokPacket::UserInfo& NtfRoomNewUser::userinfo() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomNewUser.userInfo)
  return _internal_userinfo();
}
inline void NtfRoomNewUser::unsafe_arena_set_allocated_userinfo(
    ::OmokPacket::UserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OmokPacket.NtfRoomNewUser.userInfo)
}
inline ::OmokPacket::UserInfo* NtfRoomNewUser::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OmokPacket::UserInfo* NtfRoomNewUser::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomNewUser.userInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::OmokPacket::UserInfo* NtfRoomNewUser::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::OmokPacket::UserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::OmokPacket::UserInfo* NtfRoomNewUser::mutable_userinfo() {
  ::OmokPacket::UserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomNewUser.userInfo)
  return _msg;
}
inline void NtfRoomNewUser::set_allocated_userinfo(::OmokPacket::UserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomNewUser.userInfo)
}

// -------------------------------------------------------------------

// ReqRoomLeave

// -------------------------------------------------------------------

// ResRoomLeave

// optional int32 result = 1;
inline bool ResRoomLeave::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResRoomLeave::has_result() const {
  return _internal_has_result();
}
inline void ResRoomLeave::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResRoomLeave::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResRoomLeave::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomLeave.result)
  return _internal_result();
}
inline void ResRoomLeave::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResRoomLeave::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomLeave.result)
}

// -------------------------------------------------------------------

// NtfRoomLeaveUser

// optional .OmokPacket.UserInfo userInfo = 1;
inline bool NtfRoomLeaveUser::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool NtfRoomLeaveUser::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void NtfRoomLeaveUser::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::OmokPacket::UserInfo& NtfRoomLeaveUser::_internal_userinfo() const {
  const ::OmokPacket::UserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::OmokPacket::UserInfo&>(
      ::OmokPacket::_UserInfo_default_instance_);
}
inline const ::OmokPacket::UserInfo& NtfRoomLeaveUser::userinfo() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomLeaveUser.userInfo)
  return _internal_userinfo();
}
inline void NtfRoomLeaveUser::unsafe_arena_set_allocated_userinfo(
    ::OmokPacket::UserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OmokPacket.NtfRoomLeaveUser.userInfo)
}
inline ::OmokPacket::UserInfo* NtfRoomLeaveUser::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OmokPacket::UserInfo* NtfRoomLeaveUser::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomLeaveUser.userInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::OmokPacket::UserInfo* NtfRoomLeaveUser::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::OmokPacket::UserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::OmokPacket::UserInfo* NtfRoomLeaveUser::mutable_userinfo() {
  ::OmokPacket::UserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomLeaveUser.userInfo)
  return _msg;
}
inline void NtfRoomLeaveUser::set_allocated_userinfo(::OmokPacket::UserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomLeaveUser.userInfo)
}

// -------------------------------------------------------------------

// ReqRoomChat

// optional string chat = 1;
inline bool ReqRoomChat::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqRoomChat::has_chat() const {
  return _internal_has_chat();
}
inline void ReqRoomChat::clear_chat() {
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqRoomChat::chat() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomChat.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRoomChat::set_chat(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomChat.chat)
}
inline std::string* ReqRoomChat::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqRoomChat.chat)
  return _s;
}
inline const std::string& ReqRoomChat::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void ReqRoomChat::_internal_set_chat(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRoomChat::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRoomChat::release_chat() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqRoomChat.chat)
  if (!_internal_has_chat()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.chat_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqRoomChat::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqRoomChat.chat)
}

// -------------------------------------------------------------------

// ResRoomChat

// optional int32 result = 1;
inline bool ResRoomChat::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResRoomChat::has_result() const {
  return _internal_has_result();
}
inline void ResRoomChat::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ResRoomChat::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResRoomChat::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomChat.result)
  return _internal_result();
}
inline void ResRoomChat::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void ResRoomChat::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomChat.result)
}

// optional string chat = 2;
inline bool ResRoomChat::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResRoomChat::has_chat() const {
  return _internal_has_chat();
}
inline void ResRoomChat::clear_chat() {
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResRoomChat::chat() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomChat.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResRoomChat::set_chat(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomChat.chat)
}
inline std::string* ResRoomChat::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ResRoomChat.chat)
  return _s;
}
inline const std::string& ResRoomChat::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void ResRoomChat::_internal_set_chat(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* ResRoomChat::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* ResRoomChat::release_chat() {
  // @@protoc_insertion_point(field_release:OmokPacket.ResRoomChat.chat)
  if (!_internal_has_chat()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.chat_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResRoomChat::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ResRoomChat.chat)
}

// -------------------------------------------------------------------

// NtfRoomChat

// optional .OmokPacket.UserInfo userInfo = 1;
inline bool NtfRoomChat::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool NtfRoomChat::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void NtfRoomChat::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::OmokPacket::UserInfo& NtfRoomChat::_internal_userinfo() const {
  const ::OmokPacket::UserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::OmokPacket::UserInfo&>(
      ::OmokPacket::_UserInfo_default_instance_);
}
inline const ::OmokPacket::UserInfo& NtfRoomChat::userinfo() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomChat.userInfo)
  return _internal_userinfo();
}
inline void NtfRoomChat::unsafe_arena_set_allocated_userinfo(
    ::OmokPacket::UserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OmokPacket.NtfRoomChat.userInfo)
}
inline ::OmokPacket::UserInfo* NtfRoomChat::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OmokPacket::UserInfo* NtfRoomChat::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomChat.userInfo)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::OmokPacket::UserInfo* NtfRoomChat::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::OmokPacket::UserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::OmokPacket::UserInfo* NtfRoomChat::mutable_userinfo() {
  ::OmokPacket::UserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomChat.userInfo)
  return _msg;
}
inline void NtfRoomChat::set_allocated_userinfo(::OmokPacket::UserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomChat.userInfo)
}

// optional string chat = 2;
inline bool NtfRoomChat::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfRoomChat::has_chat() const {
  return _internal_has_chat();
}
inline void NtfRoomChat::clear_chat() {
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfRoomChat::chat() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomChat.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfRoomChat::set_chat(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomChat.chat)
}
inline std::string* NtfRoomChat::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomChat.chat)
  return _s;
}
inline const std::string& NtfRoomChat::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void NtfRoomChat::_internal_set_chat(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfRoomChat::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfRoomChat::release_chat() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomChat.chat)
  if (!_internal_has_chat()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.chat_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfRoomChat::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomChat.chat)
}

// -------------------------------------------------------------------

// ReqMatch

// optional int32 sessionId = 1;
inline bool ReqMatch::_internal_has_sessionid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqMatch::has_sessionid() const {
  return _internal_has_sessionid();
}
inline void ReqMatch::clear_sessionid() {
  _impl_.sessionid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ReqMatch::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline int32_t ReqMatch::sessionid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqMatch.sessionId)
  return _internal_sessionid();
}
inline void ReqMatch::_internal_set_sessionid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sessionid_ = value;
}
inline void ReqMatch::set_sessionid(int32_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqMatch.sessionId)
}

// -------------------------------------------------------------------

// ResMatch

// optional int32 result = 1;
inline bool ResMatch::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResMatch::has_result() const {
  return _internal_has_result();
}
inline void ResMatch::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResMatch::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResMatch::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResMatch.result)
  return _internal_result();
}
inline void ResMatch::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResMatch::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResMatch.result)
}

// -------------------------------------------------------------------

// NtfMatchReq

// optional .OmokPacket.UserInfo userInfo = 1;
inline bool NtfMatchReq::_internal_has_userinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userinfo_ != nullptr);
  return value;
}
inline bool NtfMatchReq::has_userinfo() const {
  return _internal_has_userinfo();
}
inline void NtfMatchReq::clear_userinfo() {
  if (_impl_.userinfo_ != nullptr) _impl_.userinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::OmokPacket::UserInfo& NtfMatchReq::_internal_userinfo() const {
  const ::OmokPacket::UserInfo* p = _impl_.userinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::OmokPacket::UserInfo&>(
      ::OmokPacket::_UserInfo_default_instance_);
}
inline const ::OmokPacket::UserInfo& NtfMatchReq::userinfo() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfMatchReq.userInfo)
  return _internal_userinfo();
}
inline void NtfMatchReq::unsafe_arena_set_allocated_userinfo(
    ::OmokPacket::UserInfo* userinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userinfo_);
  }
  _impl_.userinfo_ = userinfo;
  if (userinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OmokPacket.NtfMatchReq.userInfo)
}
inline ::OmokPacket::UserInfo* NtfMatchReq::release_userinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OmokPacket::UserInfo* NtfMatchReq::unsafe_arena_release_userinfo() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfMatchReq.userInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::OmokPacket::UserInfo* temp = _impl_.userinfo_;
  _impl_.userinfo_ = nullptr;
  return temp;
}
inline ::OmokPacket::UserInfo* NtfMatchReq::_internal_mutable_userinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.userinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::OmokPacket::UserInfo>(GetArenaForAllocation());
    _impl_.userinfo_ = p;
  }
  return _impl_.userinfo_;
}
inline ::OmokPacket::UserInfo* NtfMatchReq::mutable_userinfo() {
  ::OmokPacket::UserInfo* _msg = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfMatchReq.userInfo)
  return _msg;
}
inline void NtfMatchReq::set_allocated_userinfo(::OmokPacket::UserInfo* userinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userinfo_;
  }
  if (userinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userinfo);
    if (message_arena != submessage_arena) {
      userinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userinfo_ = userinfo;
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfMatchReq.userInfo)
}

// -------------------------------------------------------------------

// ReqMatchRes

// optional bool accept = 1;
inline bool ReqMatchRes::_internal_has_accept() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqMatchRes::has_accept() const {
  return _internal_has_accept();
}
inline void ReqMatchRes::clear_accept() {
  _impl_.accept_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ReqMatchRes::_internal_accept() const {
  return _impl_.accept_;
}
inline bool ReqMatchRes::accept() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqMatchRes.accept)
  return _internal_accept();
}
inline void ReqMatchRes::_internal_set_accept(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accept_ = value;
}
inline void ReqMatchRes::set_accept(bool value) {
  _internal_set_accept(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqMatchRes.accept)
}

// -------------------------------------------------------------------

// ReqReadyOmok

// -------------------------------------------------------------------

// ResReadyOmok

// -------------------------------------------------------------------

// NtfStartOmok

// optional bool black = 1;
inline bool NtfStartOmok::_internal_has_black() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NtfStartOmok::has_black() const {
  return _internal_has_black();
}
inline void NtfStartOmok::clear_black() {
  _impl_.black_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NtfStartOmok::_internal_black() const {
  return _impl_.black_;
}
inline bool NtfStartOmok::black() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfStartOmok.black)
  return _internal_black();
}
inline void NtfStartOmok::_internal_set_black(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.black_ = value;
}
inline void NtfStartOmok::set_black(bool value) {
  _internal_set_black(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfStartOmok.black)
}

// optional string myId = 2;
inline bool NtfStartOmok::_internal_has_myid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfStartOmok::has_myid() const {
  return _internal_has_myid();
}
inline void NtfStartOmok::clear_myid() {
  _impl_.myid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfStartOmok::myid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfStartOmok.myId)
  return _internal_myid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfStartOmok::set_myid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.myid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfStartOmok.myId)
}
inline std::string* NtfStartOmok::mutable_myid() {
  std::string* _s = _internal_mutable_myid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfStartOmok.myId)
  return _s;
}
inline const std::string& NtfStartOmok::_internal_myid() const {
  return _impl_.myid_.Get();
}
inline void NtfStartOmok::_internal_set_myid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.myid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfStartOmok::_internal_mutable_myid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.myid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfStartOmok::release_myid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfStartOmok.myId)
  if (!_internal_has_myid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.myid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.myid_.IsDefault()) {
    _impl_.myid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfStartOmok::set_allocated_myid(std::string* myid) {
  if (myid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.myid_.SetAllocated(myid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.myid_.IsDefault()) {
    _impl_.myid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfStartOmok.myId)
}

// optional string opponentId = 3;
inline bool NtfStartOmok::_internal_has_opponentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NtfStartOmok::has_opponentid() const {
  return _internal_has_opponentid();
}
inline void NtfStartOmok::clear_opponentid() {
  _impl_.opponentid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NtfStartOmok::opponentid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfStartOmok.opponentId)
  return _internal_opponentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfStartOmok::set_opponentid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.opponentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfStartOmok.opponentId)
}
inline std::string* NtfStartOmok::mutable_opponentid() {
  std::string* _s = _internal_mutable_opponentid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfStartOmok.opponentId)
  return _s;
}
inline const std::string& NtfStartOmok::_internal_opponentid() const {
  return _impl_.opponentid_.Get();
}
inline void NtfStartOmok::_internal_set_opponentid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.opponentid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfStartOmok::_internal_mutable_opponentid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.opponentid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfStartOmok::release_opponentid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfStartOmok.opponentId)
  if (!_internal_has_opponentid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.opponentid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.opponentid_.IsDefault()) {
    _impl_.opponentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfStartOmok::set_allocated_opponentid(std::string* opponentid) {
  if (opponentid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.opponentid_.SetAllocated(opponentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.opponentid_.IsDefault()) {
    _impl_.opponentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfStartOmok.opponentId)
}

// -------------------------------------------------------------------

// ReqPutMok

// optional int32 x = 1;
inline bool ReqPutMok::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqPutMok::has_x() const {
  return _internal_has_x();
}
inline void ReqPutMok::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ReqPutMok::_internal_x() const {
  return _impl_.x_;
}
inline int32_t ReqPutMok::x() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqPutMok.x)
  return _internal_x();
}
inline void ReqPutMok::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void ReqPutMok::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqPutMok.x)
}

// optional int32 y = 2;
inline bool ReqPutMok::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReqPutMok::has_y() const {
  return _internal_has_y();
}
inline void ReqPutMok::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ReqPutMok::_internal_y() const {
  return _impl_.y_;
}
inline int32_t ReqPutMok::y() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqPutMok.y)
  return _internal_y();
}
inline void ReqPutMok::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void ReqPutMok::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqPutMok.y)
}

// -------------------------------------------------------------------

// ResPutMok

// optional int32 result = 1;
inline bool ResPutMok::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResPutMok::has_result() const {
  return _internal_has_result();
}
inline void ResPutMok::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResPutMok::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResPutMok::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResPutMok.result)
  return _internal_result();
}
inline void ResPutMok::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResPutMok::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResPutMok.result)
}

// -------------------------------------------------------------------

// NtfPutMok

// optional int32 x = 1;
inline bool NtfPutMok::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfPutMok::has_x() const {
  return _internal_has_x();
}
inline void NtfPutMok::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t NtfPutMok::_internal_x() const {
  return _impl_.x_;
}
inline int32_t NtfPutMok::x() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfPutMok.x)
  return _internal_x();
}
inline void NtfPutMok::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void NtfPutMok::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfPutMok.x)
}

// optional int32 y = 2;
inline bool NtfPutMok::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NtfPutMok::has_y() const {
  return _internal_has_y();
}
inline void NtfPutMok::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t NtfPutMok::_internal_y() const {
  return _impl_.y_;
}
inline int32_t NtfPutMok::y() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfPutMok.y)
  return _internal_y();
}
inline void NtfPutMok::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void NtfPutMok::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfPutMok.y)
}

// -------------------------------------------------------------------

// NtfEndOmok

// optional int32 status = 1;
inline bool NtfEndOmok::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfEndOmok::has_status() const {
  return _internal_has_status();
}
inline void NtfEndOmok::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t NtfEndOmok::_internal_status() const {
  return _impl_.status_;
}
inline int32_t NtfEndOmok::status() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfEndOmok.status)
  return _internal_status();
}
inline void NtfEndOmok::_internal_set_status(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}
inline void NtfEndOmok::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfEndOmok.status)
}

// -------------------------------------------------------------------

// NtfMatchTimeout

// -------------------------------------------------------------------

// NtfReadyTimeout

// -------------------------------------------------------------------

// NtfPutMokTimeout

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace OmokPacket

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_OmokPacket_2eproto
