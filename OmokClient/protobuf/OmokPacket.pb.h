// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OmokPacket.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_OmokPacket_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_OmokPacket_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_OmokPacket_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_OmokPacket_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_OmokPacket_2eproto;
namespace OmokPacket {
class NtfEndOmok;
struct NtfEndOmokDefaultTypeInternal;
extern NtfEndOmokDefaultTypeInternal _NtfEndOmok_default_instance_;
class NtfMatchUser;
struct NtfMatchUserDefaultTypeInternal;
extern NtfMatchUserDefaultTypeInternal _NtfMatchUser_default_instance_;
class NtfPutMok;
struct NtfPutMokDefaultTypeInternal;
extern NtfPutMokDefaultTypeInternal _NtfPutMok_default_instance_;
class NtfRoomChat;
struct NtfRoomChatDefaultTypeInternal;
extern NtfRoomChatDefaultTypeInternal _NtfRoomChat_default_instance_;
class NtfRoomLeaveUser;
struct NtfRoomLeaveUserDefaultTypeInternal;
extern NtfRoomLeaveUserDefaultTypeInternal _NtfRoomLeaveUser_default_instance_;
class NtfRoomNewUser;
struct NtfRoomNewUserDefaultTypeInternal;
extern NtfRoomNewUserDefaultTypeInternal _NtfRoomNewUser_default_instance_;
class NtfRoomUserList;
struct NtfRoomUserListDefaultTypeInternal;
extern NtfRoomUserListDefaultTypeInternal _NtfRoomUserList_default_instance_;
class NtfStartOmok;
struct NtfStartOmokDefaultTypeInternal;
extern NtfStartOmokDefaultTypeInternal _NtfStartOmok_default_instance_;
class ReqLogin;
struct ReqLoginDefaultTypeInternal;
extern ReqLoginDefaultTypeInternal _ReqLogin_default_instance_;
class ReqMatch;
struct ReqMatchDefaultTypeInternal;
extern ReqMatchDefaultTypeInternal _ReqMatch_default_instance_;
class ReqPutMok;
struct ReqPutMokDefaultTypeInternal;
extern ReqPutMokDefaultTypeInternal _ReqPutMok_default_instance_;
class ReqReadyOmok;
struct ReqReadyOmokDefaultTypeInternal;
extern ReqReadyOmokDefaultTypeInternal _ReqReadyOmok_default_instance_;
class ReqRoomChat;
struct ReqRoomChatDefaultTypeInternal;
extern ReqRoomChatDefaultTypeInternal _ReqRoomChat_default_instance_;
class ReqRoomEnter;
struct ReqRoomEnterDefaultTypeInternal;
extern ReqRoomEnterDefaultTypeInternal _ReqRoomEnter_default_instance_;
class ReqRoomLeave;
struct ReqRoomLeaveDefaultTypeInternal;
extern ReqRoomLeaveDefaultTypeInternal _ReqRoomLeave_default_instance_;
class ResLogin;
struct ResLoginDefaultTypeInternal;
extern ResLoginDefaultTypeInternal _ResLogin_default_instance_;
class ResMatch;
struct ResMatchDefaultTypeInternal;
extern ResMatchDefaultTypeInternal _ResMatch_default_instance_;
class ResPutMok;
struct ResPutMokDefaultTypeInternal;
extern ResPutMokDefaultTypeInternal _ResPutMok_default_instance_;
class ResReadyOmok;
struct ResReadyOmokDefaultTypeInternal;
extern ResReadyOmokDefaultTypeInternal _ResReadyOmok_default_instance_;
class ResRoomChat;
struct ResRoomChatDefaultTypeInternal;
extern ResRoomChatDefaultTypeInternal _ResRoomChat_default_instance_;
class ResRoomLeave;
struct ResRoomLeaveDefaultTypeInternal;
extern ResRoomLeaveDefaultTypeInternal _ResRoomLeave_default_instance_;
class resRoomEnter;
struct resRoomEnterDefaultTypeInternal;
extern resRoomEnterDefaultTypeInternal _resRoomEnter_default_instance_;
}  // namespace OmokPacket
PROTOBUF_NAMESPACE_OPEN
template<> ::OmokPacket::NtfEndOmok* Arena::CreateMaybeMessage<::OmokPacket::NtfEndOmok>(Arena*);
template<> ::OmokPacket::NtfMatchUser* Arena::CreateMaybeMessage<::OmokPacket::NtfMatchUser>(Arena*);
template<> ::OmokPacket::NtfPutMok* Arena::CreateMaybeMessage<::OmokPacket::NtfPutMok>(Arena*);
template<> ::OmokPacket::NtfRoomChat* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomChat>(Arena*);
template<> ::OmokPacket::NtfRoomLeaveUser* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomLeaveUser>(Arena*);
template<> ::OmokPacket::NtfRoomNewUser* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomNewUser>(Arena*);
template<> ::OmokPacket::NtfRoomUserList* Arena::CreateMaybeMessage<::OmokPacket::NtfRoomUserList>(Arena*);
template<> ::OmokPacket::NtfStartOmok* Arena::CreateMaybeMessage<::OmokPacket::NtfStartOmok>(Arena*);
template<> ::OmokPacket::ReqLogin* Arena::CreateMaybeMessage<::OmokPacket::ReqLogin>(Arena*);
template<> ::OmokPacket::ReqMatch* Arena::CreateMaybeMessage<::OmokPacket::ReqMatch>(Arena*);
template<> ::OmokPacket::ReqPutMok* Arena::CreateMaybeMessage<::OmokPacket::ReqPutMok>(Arena*);
template<> ::OmokPacket::ReqReadyOmok* Arena::CreateMaybeMessage<::OmokPacket::ReqReadyOmok>(Arena*);
template<> ::OmokPacket::ReqRoomChat* Arena::CreateMaybeMessage<::OmokPacket::ReqRoomChat>(Arena*);
template<> ::OmokPacket::ReqRoomEnter* Arena::CreateMaybeMessage<::OmokPacket::ReqRoomEnter>(Arena*);
template<> ::OmokPacket::ReqRoomLeave* Arena::CreateMaybeMessage<::OmokPacket::ReqRoomLeave>(Arena*);
template<> ::OmokPacket::ResLogin* Arena::CreateMaybeMessage<::OmokPacket::ResLogin>(Arena*);
template<> ::OmokPacket::ResMatch* Arena::CreateMaybeMessage<::OmokPacket::ResMatch>(Arena*);
template<> ::OmokPacket::ResPutMok* Arena::CreateMaybeMessage<::OmokPacket::ResPutMok>(Arena*);
template<> ::OmokPacket::ResReadyOmok* Arena::CreateMaybeMessage<::OmokPacket::ResReadyOmok>(Arena*);
template<> ::OmokPacket::ResRoomChat* Arena::CreateMaybeMessage<::OmokPacket::ResRoomChat>(Arena*);
template<> ::OmokPacket::ResRoomLeave* Arena::CreateMaybeMessage<::OmokPacket::ResRoomLeave>(Arena*);
template<> ::OmokPacket::resRoomEnter* Arena::CreateMaybeMessage<::OmokPacket::resRoomEnter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace OmokPacket {

// ===================================================================

class ReqLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqLogin) */ {
 public:
  inline ReqLogin() : ReqLogin(nullptr) {}
  ~ReqLogin() override;
  explicit PROTOBUF_CONSTEXPR ReqLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqLogin(const ReqLogin& from);
  ReqLogin(ReqLogin&& from) noexcept
    : ReqLogin() {
    *this = ::std::move(from);
  }

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqLogin& operator=(ReqLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqLogin* internal_default_instance() {
    return reinterpret_cast<const ReqLogin*>(
               &_ReqLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReqLogin& a, ReqLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqLogin& from) {
    ReqLogin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqLogin";
  }
  protected:
  explicit ReqLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPwFieldNumber = 2,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional string pw = 2;
  bool has_pw() const;
  private:
  bool _internal_has_pw() const;
  public:
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResLogin) */ {
 public:
  inline ResLogin() : ResLogin(nullptr) {}
  ~ResLogin() override;
  explicit PROTOBUF_CONSTEXPR ResLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResLogin(const ResLogin& from);
  ResLogin(ResLogin&& from) noexcept
    : ResLogin() {
    *this = ::std::move(from);
  }

  inline ResLogin& operator=(const ResLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResLogin& operator=(ResLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResLogin* internal_default_instance() {
    return reinterpret_cast<const ResLogin*>(
               &_ResLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResLogin& a, ResLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ResLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResLogin& from) {
    ResLogin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResLogin";
  }
  protected:
  explicit ResLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqRoomEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqRoomEnter) */ {
 public:
  inline ReqRoomEnter() : ReqRoomEnter(nullptr) {}
  ~ReqRoomEnter() override;
  explicit PROTOBUF_CONSTEXPR ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoomEnter(const ReqRoomEnter& from);
  ReqRoomEnter(ReqRoomEnter&& from) noexcept
    : ReqRoomEnter() {
    *this = ::std::move(from);
  }

  inline ReqRoomEnter& operator=(const ReqRoomEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoomEnter& operator=(ReqRoomEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoomEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoomEnter* internal_default_instance() {
    return reinterpret_cast<const ReqRoomEnter*>(
               &_ReqRoomEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReqRoomEnter& a, ReqRoomEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoomEnter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoomEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoomEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoomEnter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoomEnter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoomEnter& from) {
    ReqRoomEnter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoomEnter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqRoomEnter";
  }
  protected:
  explicit ReqRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kRoomNumberFieldNumber = 2,
  };
  // optional int32 roomId = 1;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // optional int32 roomNumber = 2;
  bool has_roomnumber() const;
  private:
  bool _internal_has_roomnumber() const;
  public:
  void clear_roomnumber();
  int32_t roomnumber() const;
  void set_roomnumber(int32_t value);
  private:
  int32_t _internal_roomnumber() const;
  void _internal_set_roomnumber(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqRoomEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t roomid_;
    int32_t roomnumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class resRoomEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.resRoomEnter) */ {
 public:
  inline resRoomEnter() : resRoomEnter(nullptr) {}
  ~resRoomEnter() override;
  explicit PROTOBUF_CONSTEXPR resRoomEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resRoomEnter(const resRoomEnter& from);
  resRoomEnter(resRoomEnter&& from) noexcept
    : resRoomEnter() {
    *this = ::std::move(from);
  }

  inline resRoomEnter& operator=(const resRoomEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline resRoomEnter& operator=(resRoomEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resRoomEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const resRoomEnter* internal_default_instance() {
    return reinterpret_cast<const resRoomEnter*>(
               &_resRoomEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(resRoomEnter& a, resRoomEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(resRoomEnter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resRoomEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resRoomEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resRoomEnter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resRoomEnter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resRoomEnter& from) {
    resRoomEnter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resRoomEnter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.resRoomEnter";
  }
  protected:
  explicit resRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.resRoomEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomUserList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomUserList) */ {
 public:
  inline NtfRoomUserList() : NtfRoomUserList(nullptr) {}
  ~NtfRoomUserList() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomUserList(const NtfRoomUserList& from);
  NtfRoomUserList(NtfRoomUserList&& from) noexcept
    : NtfRoomUserList() {
    *this = ::std::move(from);
  }

  inline NtfRoomUserList& operator=(const NtfRoomUserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomUserList& operator=(NtfRoomUserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomUserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomUserList* internal_default_instance() {
    return reinterpret_cast<const NtfRoomUserList*>(
               &_NtfRoomUserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NtfRoomUserList& a, NtfRoomUserList& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomUserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomUserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomUserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomUserList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomUserList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomUserList& from) {
    NtfRoomUserList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomUserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomUserList";
  }
  protected:
  explicit NtfRoomUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdListFieldNumber = 1,
  };
  // repeated string userIdList = 1;
  int useridlist_size() const;
  private:
  int _internal_useridlist_size() const;
  public:
  void clear_useridlist();
  const std::string& useridlist(int index) const;
  std::string* mutable_useridlist(int index);
  void set_useridlist(int index, const std::string& value);
  void set_useridlist(int index, std::string&& value);
  void set_useridlist(int index, const char* value);
  void set_useridlist(int index, const char* value, size_t size);
  std::string* add_useridlist();
  void add_useridlist(const std::string& value);
  void add_useridlist(std::string&& value);
  void add_useridlist(const char* value);
  void add_useridlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& useridlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_useridlist();
  private:
  const std::string& _internal_useridlist(int index) const;
  std::string* _internal_add_useridlist();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomUserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> useridlist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomNewUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomNewUser) */ {
 public:
  inline NtfRoomNewUser() : NtfRoomNewUser(nullptr) {}
  ~NtfRoomNewUser() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomNewUser(const NtfRoomNewUser& from);
  NtfRoomNewUser(NtfRoomNewUser&& from) noexcept
    : NtfRoomNewUser() {
    *this = ::std::move(from);
  }

  inline NtfRoomNewUser& operator=(const NtfRoomNewUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomNewUser& operator=(NtfRoomNewUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomNewUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomNewUser* internal_default_instance() {
    return reinterpret_cast<const NtfRoomNewUser*>(
               &_NtfRoomNewUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NtfRoomNewUser& a, NtfRoomNewUser& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomNewUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomNewUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomNewUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomNewUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomNewUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomNewUser& from) {
    NtfRoomNewUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomNewUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomNewUser";
  }
  protected:
  explicit NtfRoomNewUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomNewUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqRoomLeave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqRoomLeave) */ {
 public:
  inline ReqRoomLeave() : ReqRoomLeave(nullptr) {}
  ~ReqRoomLeave() override;
  explicit PROTOBUF_CONSTEXPR ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoomLeave(const ReqRoomLeave& from);
  ReqRoomLeave(ReqRoomLeave&& from) noexcept
    : ReqRoomLeave() {
    *this = ::std::move(from);
  }

  inline ReqRoomLeave& operator=(const ReqRoomLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoomLeave& operator=(ReqRoomLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoomLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoomLeave* internal_default_instance() {
    return reinterpret_cast<const ReqRoomLeave*>(
               &_ReqRoomLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReqRoomLeave& a, ReqRoomLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoomLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoomLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoomLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoomLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoomLeave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoomLeave& from) {
    ReqRoomLeave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoomLeave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqRoomLeave";
  }
  protected:
  explicit ReqRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqRoomLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResRoomLeave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResRoomLeave) */ {
 public:
  inline ResRoomLeave() : ResRoomLeave(nullptr) {}
  ~ResRoomLeave() override;
  explicit PROTOBUF_CONSTEXPR ResRoomLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResRoomLeave(const ResRoomLeave& from);
  ResRoomLeave(ResRoomLeave&& from) noexcept
    : ResRoomLeave() {
    *this = ::std::move(from);
  }

  inline ResRoomLeave& operator=(const ResRoomLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResRoomLeave& operator=(ResRoomLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResRoomLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResRoomLeave* internal_default_instance() {
    return reinterpret_cast<const ResRoomLeave*>(
               &_ResRoomLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResRoomLeave& a, ResRoomLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(ResRoomLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResRoomLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResRoomLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResRoomLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResRoomLeave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResRoomLeave& from) {
    ResRoomLeave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResRoomLeave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResRoomLeave";
  }
  protected:
  explicit ResRoomLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResRoomLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomLeaveUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomLeaveUser) */ {
 public:
  inline NtfRoomLeaveUser() : NtfRoomLeaveUser(nullptr) {}
  ~NtfRoomLeaveUser() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomLeaveUser(const NtfRoomLeaveUser& from);
  NtfRoomLeaveUser(NtfRoomLeaveUser&& from) noexcept
    : NtfRoomLeaveUser() {
    *this = ::std::move(from);
  }

  inline NtfRoomLeaveUser& operator=(const NtfRoomLeaveUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomLeaveUser& operator=(NtfRoomLeaveUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomLeaveUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomLeaveUser* internal_default_instance() {
    return reinterpret_cast<const NtfRoomLeaveUser*>(
               &_NtfRoomLeaveUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NtfRoomLeaveUser& a, NtfRoomLeaveUser& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomLeaveUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomLeaveUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomLeaveUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomLeaveUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomLeaveUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomLeaveUser& from) {
    NtfRoomLeaveUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomLeaveUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomLeaveUser";
  }
  protected:
  explicit NtfRoomLeaveUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomLeaveUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqRoomChat) */ {
 public:
  inline ReqRoomChat() : ReqRoomChat(nullptr) {}
  ~ReqRoomChat() override;
  explicit PROTOBUF_CONSTEXPR ReqRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoomChat(const ReqRoomChat& from);
  ReqRoomChat(ReqRoomChat&& from) noexcept
    : ReqRoomChat() {
    *this = ::std::move(from);
  }

  inline ReqRoomChat& operator=(const ReqRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoomChat& operator=(ReqRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoomChat* internal_default_instance() {
    return reinterpret_cast<const ReqRoomChat*>(
               &_ReqRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReqRoomChat& a, ReqRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoomChat& from) {
    ReqRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqRoomChat";
  }
  protected:
  explicit ReqRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kChatFieldNumber = 2,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional string chat = 2;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResRoomChat) */ {
 public:
  inline ResRoomChat() : ResRoomChat(nullptr) {}
  ~ResRoomChat() override;
  explicit PROTOBUF_CONSTEXPR ResRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResRoomChat(const ResRoomChat& from);
  ResRoomChat(ResRoomChat&& from) noexcept
    : ResRoomChat() {
    *this = ::std::move(from);
  }

  inline ResRoomChat& operator=(const ResRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResRoomChat& operator=(ResRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResRoomChat* internal_default_instance() {
    return reinterpret_cast<const ResRoomChat*>(
               &_ResRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResRoomChat& a, ResRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ResRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResRoomChat& from) {
    ResRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResRoomChat";
  }
  protected:
  explicit ResRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kChatFieldNumber = 2,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional string chat = 2;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfRoomChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfRoomChat) */ {
 public:
  inline NtfRoomChat() : NtfRoomChat(nullptr) {}
  ~NtfRoomChat() override;
  explicit PROTOBUF_CONSTEXPR NtfRoomChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfRoomChat(const NtfRoomChat& from);
  NtfRoomChat(NtfRoomChat&& from) noexcept
    : NtfRoomChat() {
    *this = ::std::move(from);
  }

  inline NtfRoomChat& operator=(const NtfRoomChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfRoomChat& operator=(NtfRoomChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfRoomChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfRoomChat* internal_default_instance() {
    return reinterpret_cast<const NtfRoomChat*>(
               &_NtfRoomChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NtfRoomChat& a, NtfRoomChat& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfRoomChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfRoomChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfRoomChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfRoomChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfRoomChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfRoomChat& from) {
    NtfRoomChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfRoomChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfRoomChat";
  }
  protected:
  explicit NtfRoomChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kChatFieldNumber = 2,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional string chat = 2;
  bool has_chat() const;
  private:
  bool _internal_has_chat() const;
  public:
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfRoomChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqMatch) */ {
 public:
  inline ReqMatch() : ReqMatch(nullptr) {}
  ~ReqMatch() override;
  explicit PROTOBUF_CONSTEXPR ReqMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqMatch(const ReqMatch& from);
  ReqMatch(ReqMatch&& from) noexcept
    : ReqMatch() {
    *this = ::std::move(from);
  }

  inline ReqMatch& operator=(const ReqMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqMatch& operator=(ReqMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqMatch* internal_default_instance() {
    return reinterpret_cast<const ReqMatch*>(
               &_ReqMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReqMatch& a, ReqMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqMatch& from) {
    ReqMatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqMatch";
  }
  protected:
  explicit ReqMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResMatch) */ {
 public:
  inline ResMatch() : ResMatch(nullptr) {}
  ~ResMatch() override;
  explicit PROTOBUF_CONSTEXPR ResMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResMatch(const ResMatch& from);
  ResMatch(ResMatch&& from) noexcept
    : ResMatch() {
    *this = ::std::move(from);
  }

  inline ResMatch& operator=(const ResMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResMatch& operator=(ResMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResMatch* internal_default_instance() {
    return reinterpret_cast<const ResMatch*>(
               &_ResMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResMatch& a, ResMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ResMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResMatch& from) {
    ResMatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResMatch";
  }
  protected:
  explicit ResMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfMatchUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfMatchUser) */ {
 public:
  inline NtfMatchUser() : NtfMatchUser(nullptr) {}
  ~NtfMatchUser() override;
  explicit PROTOBUF_CONSTEXPR NtfMatchUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfMatchUser(const NtfMatchUser& from);
  NtfMatchUser(NtfMatchUser&& from) noexcept
    : NtfMatchUser() {
    *this = ::std::move(from);
  }

  inline NtfMatchUser& operator=(const NtfMatchUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfMatchUser& operator=(NtfMatchUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfMatchUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfMatchUser* internal_default_instance() {
    return reinterpret_cast<const NtfMatchUser*>(
               &_NtfMatchUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NtfMatchUser& a, NtfMatchUser& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfMatchUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfMatchUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfMatchUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfMatchUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfMatchUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfMatchUser& from) {
    NtfMatchUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfMatchUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfMatchUser";
  }
  protected:
  explicit NtfMatchUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfMatchUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqReadyOmok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqReadyOmok) */ {
 public:
  inline ReqReadyOmok() : ReqReadyOmok(nullptr) {}
  ~ReqReadyOmok() override;
  explicit PROTOBUF_CONSTEXPR ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqReadyOmok(const ReqReadyOmok& from);
  ReqReadyOmok(ReqReadyOmok&& from) noexcept
    : ReqReadyOmok() {
    *this = ::std::move(from);
  }

  inline ReqReadyOmok& operator=(const ReqReadyOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqReadyOmok& operator=(ReqReadyOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqReadyOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqReadyOmok* internal_default_instance() {
    return reinterpret_cast<const ReqReadyOmok*>(
               &_ReqReadyOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReqReadyOmok& a, ReqReadyOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqReadyOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqReadyOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqReadyOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqReadyOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqReadyOmok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqReadyOmok& from) {
    ReqReadyOmok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqReadyOmok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqReadyOmok";
  }
  protected:
  explicit ReqReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqReadyOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResReadyOmok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResReadyOmok) */ {
 public:
  inline ResReadyOmok() : ResReadyOmok(nullptr) {}
  ~ResReadyOmok() override;
  explicit PROTOBUF_CONSTEXPR ResReadyOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResReadyOmok(const ResReadyOmok& from);
  ResReadyOmok(ResReadyOmok&& from) noexcept
    : ResReadyOmok() {
    *this = ::std::move(from);
  }

  inline ResReadyOmok& operator=(const ResReadyOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResReadyOmok& operator=(ResReadyOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResReadyOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResReadyOmok* internal_default_instance() {
    return reinterpret_cast<const ResReadyOmok*>(
               &_ResReadyOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ResReadyOmok& a, ResReadyOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(ResReadyOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResReadyOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResReadyOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResReadyOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResReadyOmok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResReadyOmok& from) {
    ResReadyOmok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResReadyOmok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResReadyOmok";
  }
  protected:
  explicit ResReadyOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResReadyOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfStartOmok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfStartOmok) */ {
 public:
  inline NtfStartOmok() : NtfStartOmok(nullptr) {}
  ~NtfStartOmok() override;
  explicit PROTOBUF_CONSTEXPR NtfStartOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfStartOmok(const NtfStartOmok& from);
  NtfStartOmok(NtfStartOmok&& from) noexcept
    : NtfStartOmok() {
    *this = ::std::move(from);
  }

  inline NtfStartOmok& operator=(const NtfStartOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfStartOmok& operator=(NtfStartOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfStartOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfStartOmok* internal_default_instance() {
    return reinterpret_cast<const NtfStartOmok*>(
               &_NtfStartOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NtfStartOmok& a, NtfStartOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfStartOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfStartOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfStartOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfStartOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfStartOmok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfStartOmok& from) {
    NtfStartOmok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfStartOmok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfStartOmok";
  }
  protected:
  explicit NtfStartOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstUserIdFieldNumber = 1,
    kSecondUserIdFieldNumber = 2,
  };
  // optional string firstUserId = 1;
  bool has_firstuserid() const;
  private:
  bool _internal_has_firstuserid() const;
  public:
  void clear_firstuserid();
  const std::string& firstuserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firstuserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firstuserid();
  PROTOBUF_NODISCARD std::string* release_firstuserid();
  void set_allocated_firstuserid(std::string* firstuserid);
  private:
  const std::string& _internal_firstuserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firstuserid(const std::string& value);
  std::string* _internal_mutable_firstuserid();
  public:

  // optional string secondUserId = 2;
  bool has_seconduserid() const;
  private:
  bool _internal_has_seconduserid() const;
  public:
  void clear_seconduserid();
  const std::string& seconduserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seconduserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seconduserid();
  PROTOBUF_NODISCARD std::string* release_seconduserid();
  void set_allocated_seconduserid(std::string* seconduserid);
  private:
  const std::string& _internal_seconduserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seconduserid(const std::string& value);
  std::string* _internal_mutable_seconduserid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfStartOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firstuserid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seconduserid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ReqPutMok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ReqPutMok) */ {
 public:
  inline ReqPutMok() : ReqPutMok(nullptr) {}
  ~ReqPutMok() override;
  explicit PROTOBUF_CONSTEXPR ReqPutMok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqPutMok(const ReqPutMok& from);
  ReqPutMok(ReqPutMok&& from) noexcept
    : ReqPutMok() {
    *this = ::std::move(from);
  }

  inline ReqPutMok& operator=(const ReqPutMok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqPutMok& operator=(ReqPutMok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqPutMok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqPutMok* internal_default_instance() {
    return reinterpret_cast<const ReqPutMok*>(
               &_ReqPutMok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReqPutMok& a, ReqPutMok& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqPutMok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqPutMok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqPutMok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqPutMok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqPutMok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqPutMok& from) {
    ReqPutMok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqPutMok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ReqPutMok";
  }
  protected:
  explicit ReqPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional int32 x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ReqPutMok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class ResPutMok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.ResPutMok) */ {
 public:
  inline ResPutMok() : ResPutMok(nullptr) {}
  ~ResPutMok() override;
  explicit PROTOBUF_CONSTEXPR ResPutMok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResPutMok(const ResPutMok& from);
  ResPutMok(ResPutMok&& from) noexcept
    : ResPutMok() {
    *this = ::std::move(from);
  }

  inline ResPutMok& operator=(const ResPutMok& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResPutMok& operator=(ResPutMok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResPutMok& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResPutMok* internal_default_instance() {
    return reinterpret_cast<const ResPutMok*>(
               &_ResPutMok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResPutMok& a, ResPutMok& b) {
    a.Swap(&b);
  }
  inline void Swap(ResPutMok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResPutMok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResPutMok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResPutMok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResPutMok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResPutMok& from) {
    ResPutMok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResPutMok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.ResPutMok";
  }
  protected:
  explicit ResPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.ResPutMok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfPutMok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfPutMok) */ {
 public:
  inline NtfPutMok() : NtfPutMok(nullptr) {}
  ~NtfPutMok() override;
  explicit PROTOBUF_CONSTEXPR NtfPutMok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfPutMok(const NtfPutMok& from);
  NtfPutMok(NtfPutMok&& from) noexcept
    : NtfPutMok() {
    *this = ::std::move(from);
  }

  inline NtfPutMok& operator=(const NtfPutMok& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfPutMok& operator=(NtfPutMok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfPutMok& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfPutMok* internal_default_instance() {
    return reinterpret_cast<const NtfPutMok*>(
               &_NtfPutMok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(NtfPutMok& a, NtfPutMok& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfPutMok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfPutMok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfPutMok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfPutMok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfPutMok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfPutMok& from) {
    NtfPutMok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfPutMok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfPutMok";
  }
  protected:
  explicit NtfPutMok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // optional string userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional int32 x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfPutMok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// -------------------------------------------------------------------

class NtfEndOmok final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OmokPacket.NtfEndOmok) */ {
 public:
  inline NtfEndOmok() : NtfEndOmok(nullptr) {}
  ~NtfEndOmok() override;
  explicit PROTOBUF_CONSTEXPR NtfEndOmok(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtfEndOmok(const NtfEndOmok& from);
  NtfEndOmok(NtfEndOmok&& from) noexcept
    : NtfEndOmok() {
    *this = ::std::move(from);
  }

  inline NtfEndOmok& operator=(const NtfEndOmok& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtfEndOmok& operator=(NtfEndOmok&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NtfEndOmok& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtfEndOmok* internal_default_instance() {
    return reinterpret_cast<const NtfEndOmok*>(
               &_NtfEndOmok_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NtfEndOmok& a, NtfEndOmok& b) {
    a.Swap(&b);
  }
  inline void Swap(NtfEndOmok* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtfEndOmok* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NtfEndOmok* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NtfEndOmok>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NtfEndOmok& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NtfEndOmok& from) {
    NtfEndOmok::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NtfEndOmok* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OmokPacket.NtfEndOmok";
  }
  protected:
  explicit NtfEndOmok(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWinnerUserIdFieldNumber = 1,
  };
  // optional string winnerUserId = 1;
  bool has_winneruserid() const;
  private:
  bool _internal_has_winneruserid() const;
  public:
  void clear_winneruserid();
  const std::string& winneruserid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_winneruserid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_winneruserid();
  PROTOBUF_NODISCARD std::string* release_winneruserid();
  void set_allocated_winneruserid(std::string* winneruserid);
  private:
  const std::string& _internal_winneruserid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_winneruserid(const std::string& value);
  std::string* _internal_mutable_winneruserid();
  public:

  // @@protoc_insertion_point(class_scope:OmokPacket.NtfEndOmok)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr winneruserid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_OmokPacket_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqLogin

// optional string userId = 1;
inline bool ReqLogin::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqLogin::has_userid() const {
  return _internal_has_userid();
}
inline void ReqLogin::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqLogin::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqLogin.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLogin::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqLogin.userId)
}
inline std::string* ReqLogin::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqLogin.userId)
  return _s;
}
inline const std::string& ReqLogin::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqLogin::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLogin::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLogin::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqLogin.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqLogin::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqLogin.userId)
}

// optional string pw = 2;
inline bool ReqLogin::_internal_has_pw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReqLogin::has_pw() const {
  return _internal_has_pw();
}
inline void ReqLogin::clear_pw() {
  _impl_.pw_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReqLogin::pw() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqLogin.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLogin::set_pw(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pw_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqLogin.pw)
}
inline std::string* ReqLogin::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqLogin.pw)
  return _s;
}
inline const std::string& ReqLogin::_internal_pw() const {
  return _impl_.pw_.Get();
}
inline void ReqLogin::_internal_set_pw(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pw_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLogin::_internal_mutable_pw() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pw_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLogin::release_pw() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqLogin.pw)
  if (!_internal_has_pw()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pw_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqLogin::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pw_.SetAllocated(pw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqLogin.pw)
}

// -------------------------------------------------------------------

// ResLogin

// optional int32 result = 1;
inline bool ResLogin::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResLogin::has_result() const {
  return _internal_has_result();
}
inline void ResLogin::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResLogin::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResLogin::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResLogin.result)
  return _internal_result();
}
inline void ResLogin::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResLogin::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResLogin.result)
}

// -------------------------------------------------------------------

// ReqRoomEnter

// optional int32 roomId = 1;
inline bool ReqRoomEnter::_internal_has_roomid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqRoomEnter::has_roomid() const {
  return _internal_has_roomid();
}
inline void ReqRoomEnter::clear_roomid() {
  _impl_.roomid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ReqRoomEnter::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t ReqRoomEnter::roomid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomEnter.roomId)
  return _internal_roomid();
}
inline void ReqRoomEnter::_internal_set_roomid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.roomid_ = value;
}
inline void ReqRoomEnter::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomEnter.roomId)
}

// optional int32 roomNumber = 2;
inline bool ReqRoomEnter::_internal_has_roomnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReqRoomEnter::has_roomnumber() const {
  return _internal_has_roomnumber();
}
inline void ReqRoomEnter::clear_roomnumber() {
  _impl_.roomnumber_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ReqRoomEnter::_internal_roomnumber() const {
  return _impl_.roomnumber_;
}
inline int32_t ReqRoomEnter::roomnumber() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomEnter.roomNumber)
  return _internal_roomnumber();
}
inline void ReqRoomEnter::_internal_set_roomnumber(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roomnumber_ = value;
}
inline void ReqRoomEnter::set_roomnumber(int32_t value) {
  _internal_set_roomnumber(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomEnter.roomNumber)
}

// -------------------------------------------------------------------

// resRoomEnter

// optional int32 result = 1;
inline bool resRoomEnter::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resRoomEnter::has_result() const {
  return _internal_has_result();
}
inline void resRoomEnter::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t resRoomEnter::_internal_result() const {
  return _impl_.result_;
}
inline int32_t resRoomEnter::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.resRoomEnter.result)
  return _internal_result();
}
inline void resRoomEnter::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void resRoomEnter::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.resRoomEnter.result)
}

// -------------------------------------------------------------------

// NtfRoomUserList

// repeated string userIdList = 1;
inline int NtfRoomUserList::_internal_useridlist_size() const {
  return _impl_.useridlist_.size();
}
inline int NtfRoomUserList::useridlist_size() const {
  return _internal_useridlist_size();
}
inline void NtfRoomUserList::clear_useridlist() {
  _impl_.useridlist_.Clear();
}
inline std::string* NtfRoomUserList::add_useridlist() {
  std::string* _s = _internal_add_useridlist();
  // @@protoc_insertion_point(field_add_mutable:OmokPacket.NtfRoomUserList.userIdList)
  return _s;
}
inline const std::string& NtfRoomUserList::_internal_useridlist(int index) const {
  return _impl_.useridlist_.Get(index);
}
inline const std::string& NtfRoomUserList::useridlist(int index) const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomUserList.userIdList)
  return _internal_useridlist(index);
}
inline std::string* NtfRoomUserList::mutable_useridlist(int index) {
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomUserList.userIdList)
  return _impl_.useridlist_.Mutable(index);
}
inline void NtfRoomUserList::set_useridlist(int index, const std::string& value) {
  _impl_.useridlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomUserList.userIdList)
}
inline void NtfRoomUserList::set_useridlist(int index, std::string&& value) {
  _impl_.useridlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomUserList.userIdList)
}
inline void NtfRoomUserList::set_useridlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.useridlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OmokPacket.NtfRoomUserList.userIdList)
}
inline void NtfRoomUserList::set_useridlist(int index, const char* value, size_t size) {
  _impl_.useridlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OmokPacket.NtfRoomUserList.userIdList)
}
inline std::string* NtfRoomUserList::_internal_add_useridlist() {
  return _impl_.useridlist_.Add();
}
inline void NtfRoomUserList::add_useridlist(const std::string& value) {
  _impl_.useridlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OmokPacket.NtfRoomUserList.userIdList)
}
inline void NtfRoomUserList::add_useridlist(std::string&& value) {
  _impl_.useridlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:OmokPacket.NtfRoomUserList.userIdList)
}
inline void NtfRoomUserList::add_useridlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.useridlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OmokPacket.NtfRoomUserList.userIdList)
}
inline void NtfRoomUserList::add_useridlist(const char* value, size_t size) {
  _impl_.useridlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OmokPacket.NtfRoomUserList.userIdList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NtfRoomUserList::useridlist() const {
  // @@protoc_insertion_point(field_list:OmokPacket.NtfRoomUserList.userIdList)
  return _impl_.useridlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NtfRoomUserList::mutable_useridlist() {
  // @@protoc_insertion_point(field_mutable_list:OmokPacket.NtfRoomUserList.userIdList)
  return &_impl_.useridlist_;
}

// -------------------------------------------------------------------

// NtfRoomNewUser

// optional string userId = 1;
inline bool NtfRoomNewUser::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfRoomNewUser::has_userid() const {
  return _internal_has_userid();
}
inline void NtfRoomNewUser::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfRoomNewUser::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomNewUser.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfRoomNewUser::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomNewUser.userId)
}
inline std::string* NtfRoomNewUser::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomNewUser.userId)
  return _s;
}
inline const std::string& NtfRoomNewUser::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void NtfRoomNewUser::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfRoomNewUser::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfRoomNewUser::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomNewUser.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfRoomNewUser::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomNewUser.userId)
}

// -------------------------------------------------------------------

// ReqRoomLeave

// optional string userId = 1;
inline bool ReqRoomLeave::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqRoomLeave::has_userid() const {
  return _internal_has_userid();
}
inline void ReqRoomLeave::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqRoomLeave::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomLeave.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRoomLeave::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomLeave.userId)
}
inline std::string* ReqRoomLeave::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqRoomLeave.userId)
  return _s;
}
inline const std::string& ReqRoomLeave::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqRoomLeave::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRoomLeave::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRoomLeave::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqRoomLeave.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqRoomLeave::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqRoomLeave.userId)
}

// -------------------------------------------------------------------

// ResRoomLeave

// optional int32 result = 1;
inline bool ResRoomLeave::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResRoomLeave::has_result() const {
  return _internal_has_result();
}
inline void ResRoomLeave::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResRoomLeave::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResRoomLeave::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomLeave.result)
  return _internal_result();
}
inline void ResRoomLeave::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResRoomLeave::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomLeave.result)
}

// -------------------------------------------------------------------

// NtfRoomLeaveUser

// optional string userId = 1;
inline bool NtfRoomLeaveUser::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfRoomLeaveUser::has_userid() const {
  return _internal_has_userid();
}
inline void NtfRoomLeaveUser::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfRoomLeaveUser::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomLeaveUser.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfRoomLeaveUser::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomLeaveUser.userId)
}
inline std::string* NtfRoomLeaveUser::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomLeaveUser.userId)
  return _s;
}
inline const std::string& NtfRoomLeaveUser::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void NtfRoomLeaveUser::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfRoomLeaveUser::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfRoomLeaveUser::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomLeaveUser.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfRoomLeaveUser::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomLeaveUser.userId)
}

// -------------------------------------------------------------------

// ReqRoomChat

// optional string userId = 1;
inline bool ReqRoomChat::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqRoomChat::has_userid() const {
  return _internal_has_userid();
}
inline void ReqRoomChat::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqRoomChat::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomChat.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRoomChat::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomChat.userId)
}
inline std::string* ReqRoomChat::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqRoomChat.userId)
  return _s;
}
inline const std::string& ReqRoomChat::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqRoomChat::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRoomChat::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRoomChat::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqRoomChat.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqRoomChat::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqRoomChat.userId)
}

// optional string chat = 2;
inline bool ReqRoomChat::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReqRoomChat::has_chat() const {
  return _internal_has_chat();
}
inline void ReqRoomChat::clear_chat() {
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReqRoomChat::chat() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqRoomChat.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqRoomChat::set_chat(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqRoomChat.chat)
}
inline std::string* ReqRoomChat::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqRoomChat.chat)
  return _s;
}
inline const std::string& ReqRoomChat::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void ReqRoomChat::_internal_set_chat(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqRoomChat::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqRoomChat::release_chat() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqRoomChat.chat)
  if (!_internal_has_chat()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.chat_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqRoomChat::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqRoomChat.chat)
}

// -------------------------------------------------------------------

// ResRoomChat

// optional string userId = 1;
inline bool ResRoomChat::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResRoomChat::has_userid() const {
  return _internal_has_userid();
}
inline void ResRoomChat::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResRoomChat::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomChat.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResRoomChat::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomChat.userId)
}
inline std::string* ResRoomChat::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ResRoomChat.userId)
  return _s;
}
inline const std::string& ResRoomChat::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ResRoomChat::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ResRoomChat::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ResRoomChat::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ResRoomChat.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResRoomChat::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ResRoomChat.userId)
}

// optional string chat = 2;
inline bool ResRoomChat::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResRoomChat::has_chat() const {
  return _internal_has_chat();
}
inline void ResRoomChat::clear_chat() {
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResRoomChat::chat() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResRoomChat.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResRoomChat::set_chat(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ResRoomChat.chat)
}
inline std::string* ResRoomChat::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ResRoomChat.chat)
  return _s;
}
inline const std::string& ResRoomChat::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void ResRoomChat::_internal_set_chat(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* ResRoomChat::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* ResRoomChat::release_chat() {
  // @@protoc_insertion_point(field_release:OmokPacket.ResRoomChat.chat)
  if (!_internal_has_chat()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.chat_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResRoomChat::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ResRoomChat.chat)
}

// -------------------------------------------------------------------

// NtfRoomChat

// optional string userId = 1;
inline bool NtfRoomChat::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfRoomChat::has_userid() const {
  return _internal_has_userid();
}
inline void NtfRoomChat::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfRoomChat::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomChat.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfRoomChat::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomChat.userId)
}
inline std::string* NtfRoomChat::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomChat.userId)
  return _s;
}
inline const std::string& NtfRoomChat::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void NtfRoomChat::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfRoomChat::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfRoomChat::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomChat.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfRoomChat::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomChat.userId)
}

// optional string chat = 2;
inline bool NtfRoomChat::_internal_has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NtfRoomChat::has_chat() const {
  return _internal_has_chat();
}
inline void NtfRoomChat::clear_chat() {
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NtfRoomChat::chat() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfRoomChat.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfRoomChat::set_chat(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfRoomChat.chat)
}
inline std::string* NtfRoomChat::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfRoomChat.chat)
  return _s;
}
inline const std::string& NtfRoomChat::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void NtfRoomChat::_internal_set_chat(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfRoomChat::_internal_mutable_chat() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfRoomChat::release_chat() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfRoomChat.chat)
  if (!_internal_has_chat()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.chat_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfRoomChat::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfRoomChat.chat)
}

// -------------------------------------------------------------------

// ReqMatch

// optional string userId = 1;
inline bool ReqMatch::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqMatch::has_userid() const {
  return _internal_has_userid();
}
inline void ReqMatch::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqMatch::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqMatch.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqMatch::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqMatch.userId)
}
inline std::string* ReqMatch::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqMatch.userId)
  return _s;
}
inline const std::string& ReqMatch::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqMatch::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqMatch::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqMatch::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqMatch.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqMatch::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqMatch.userId)
}

// -------------------------------------------------------------------

// ResMatch

// optional int32 result = 1;
inline bool ResMatch::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResMatch::has_result() const {
  return _internal_has_result();
}
inline void ResMatch::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResMatch::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResMatch::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResMatch.result)
  return _internal_result();
}
inline void ResMatch::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResMatch::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResMatch.result)
}

// -------------------------------------------------------------------

// NtfMatchUser

// optional string userId = 1;
inline bool NtfMatchUser::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfMatchUser::has_userid() const {
  return _internal_has_userid();
}
inline void NtfMatchUser::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfMatchUser::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfMatchUser.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfMatchUser::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfMatchUser.userId)
}
inline std::string* NtfMatchUser::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfMatchUser.userId)
  return _s;
}
inline const std::string& NtfMatchUser::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void NtfMatchUser::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfMatchUser::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfMatchUser::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfMatchUser.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfMatchUser::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfMatchUser.userId)
}

// -------------------------------------------------------------------

// ReqReadyOmok

// optional string userId = 1;
inline bool ReqReadyOmok::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqReadyOmok::has_userid() const {
  return _internal_has_userid();
}
inline void ReqReadyOmok::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqReadyOmok::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqReadyOmok.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqReadyOmok::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqReadyOmok.userId)
}
inline std::string* ReqReadyOmok::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqReadyOmok.userId)
  return _s;
}
inline const std::string& ReqReadyOmok::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqReadyOmok::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqReadyOmok::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqReadyOmok::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqReadyOmok.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqReadyOmok::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqReadyOmok.userId)
}

// -------------------------------------------------------------------

// ResReadyOmok

// optional int32 result = 1;
inline bool ResReadyOmok::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResReadyOmok::has_result() const {
  return _internal_has_result();
}
inline void ResReadyOmok::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResReadyOmok::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResReadyOmok::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResReadyOmok.result)
  return _internal_result();
}
inline void ResReadyOmok::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResReadyOmok::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResReadyOmok.result)
}

// -------------------------------------------------------------------

// NtfStartOmok

// optional string firstUserId = 1;
inline bool NtfStartOmok::_internal_has_firstuserid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfStartOmok::has_firstuserid() const {
  return _internal_has_firstuserid();
}
inline void NtfStartOmok::clear_firstuserid() {
  _impl_.firstuserid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfStartOmok::firstuserid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfStartOmok.firstUserId)
  return _internal_firstuserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfStartOmok::set_firstuserid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.firstuserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfStartOmok.firstUserId)
}
inline std::string* NtfStartOmok::mutable_firstuserid() {
  std::string* _s = _internal_mutable_firstuserid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfStartOmok.firstUserId)
  return _s;
}
inline const std::string& NtfStartOmok::_internal_firstuserid() const {
  return _impl_.firstuserid_.Get();
}
inline void NtfStartOmok::_internal_set_firstuserid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.firstuserid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfStartOmok::_internal_mutable_firstuserid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.firstuserid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfStartOmok::release_firstuserid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfStartOmok.firstUserId)
  if (!_internal_has_firstuserid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.firstuserid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstuserid_.IsDefault()) {
    _impl_.firstuserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfStartOmok::set_allocated_firstuserid(std::string* firstuserid) {
  if (firstuserid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.firstuserid_.SetAllocated(firstuserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firstuserid_.IsDefault()) {
    _impl_.firstuserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfStartOmok.firstUserId)
}

// optional string secondUserId = 2;
inline bool NtfStartOmok::_internal_has_seconduserid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NtfStartOmok::has_seconduserid() const {
  return _internal_has_seconduserid();
}
inline void NtfStartOmok::clear_seconduserid() {
  _impl_.seconduserid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NtfStartOmok::seconduserid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfStartOmok.secondUserId)
  return _internal_seconduserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfStartOmok::set_seconduserid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.seconduserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfStartOmok.secondUserId)
}
inline std::string* NtfStartOmok::mutable_seconduserid() {
  std::string* _s = _internal_mutable_seconduserid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfStartOmok.secondUserId)
  return _s;
}
inline const std::string& NtfStartOmok::_internal_seconduserid() const {
  return _impl_.seconduserid_.Get();
}
inline void NtfStartOmok::_internal_set_seconduserid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seconduserid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfStartOmok::_internal_mutable_seconduserid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.seconduserid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfStartOmok::release_seconduserid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfStartOmok.secondUserId)
  if (!_internal_has_seconduserid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.seconduserid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seconduserid_.IsDefault()) {
    _impl_.seconduserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfStartOmok::set_allocated_seconduserid(std::string* seconduserid) {
  if (seconduserid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.seconduserid_.SetAllocated(seconduserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seconduserid_.IsDefault()) {
    _impl_.seconduserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfStartOmok.secondUserId)
}

// -------------------------------------------------------------------

// ReqPutMok

// optional string userId = 1;
inline bool ReqPutMok::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReqPutMok::has_userid() const {
  return _internal_has_userid();
}
inline void ReqPutMok::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReqPutMok::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqPutMok.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqPutMok::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.ReqPutMok.userId)
}
inline std::string* ReqPutMok::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.ReqPutMok.userId)
  return _s;
}
inline const std::string& ReqPutMok::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ReqPutMok::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqPutMok::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqPutMok::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.ReqPutMok.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReqPutMok::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.ReqPutMok.userId)
}

// optional int32 x = 2;
inline bool ReqPutMok::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReqPutMok::has_x() const {
  return _internal_has_x();
}
inline void ReqPutMok::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ReqPutMok::_internal_x() const {
  return _impl_.x_;
}
inline int32_t ReqPutMok::x() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqPutMok.x)
  return _internal_x();
}
inline void ReqPutMok::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void ReqPutMok::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqPutMok.x)
}

// optional int32 y = 3;
inline bool ReqPutMok::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReqPutMok::has_y() const {
  return _internal_has_y();
}
inline void ReqPutMok::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t ReqPutMok::_internal_y() const {
  return _impl_.y_;
}
inline int32_t ReqPutMok::y() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ReqPutMok.y)
  return _internal_y();
}
inline void ReqPutMok::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void ReqPutMok::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ReqPutMok.y)
}

// -------------------------------------------------------------------

// ResPutMok

// optional int32 result = 1;
inline bool ResPutMok::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResPutMok::has_result() const {
  return _internal_has_result();
}
inline void ResPutMok::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResPutMok::_internal_result() const {
  return _impl_.result_;
}
inline int32_t ResPutMok::result() const {
  // @@protoc_insertion_point(field_get:OmokPacket.ResPutMok.result)
  return _internal_result();
}
inline void ResPutMok::_internal_set_result(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void ResPutMok::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:OmokPacket.ResPutMok.result)
}

// -------------------------------------------------------------------

// NtfPutMok

// optional string userId = 1;
inline bool NtfPutMok::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfPutMok::has_userid() const {
  return _internal_has_userid();
}
inline void NtfPutMok::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfPutMok::userid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfPutMok.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfPutMok::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfPutMok.userId)
}
inline std::string* NtfPutMok::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfPutMok.userId)
  return _s;
}
inline const std::string& NtfPutMok::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void NtfPutMok::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfPutMok::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfPutMok::release_userid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfPutMok.userId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfPutMok::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfPutMok.userId)
}

// optional int32 x = 2;
inline bool NtfPutMok::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NtfPutMok::has_x() const {
  return _internal_has_x();
}
inline void NtfPutMok::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t NtfPutMok::_internal_x() const {
  return _impl_.x_;
}
inline int32_t NtfPutMok::x() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfPutMok.x)
  return _internal_x();
}
inline void NtfPutMok::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void NtfPutMok::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfPutMok.x)
}

// optional int32 y = 3;
inline bool NtfPutMok::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NtfPutMok::has_y() const {
  return _internal_has_y();
}
inline void NtfPutMok::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t NtfPutMok::_internal_y() const {
  return _impl_.y_;
}
inline int32_t NtfPutMok::y() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfPutMok.y)
  return _internal_y();
}
inline void NtfPutMok::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void NtfPutMok::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:OmokPacket.NtfPutMok.y)
}

// -------------------------------------------------------------------

// NtfEndOmok

// optional string winnerUserId = 1;
inline bool NtfEndOmok::_internal_has_winneruserid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtfEndOmok::has_winneruserid() const {
  return _internal_has_winneruserid();
}
inline void NtfEndOmok::clear_winneruserid() {
  _impl_.winneruserid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NtfEndOmok::winneruserid() const {
  // @@protoc_insertion_point(field_get:OmokPacket.NtfEndOmok.winnerUserId)
  return _internal_winneruserid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NtfEndOmok::set_winneruserid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.winneruserid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OmokPacket.NtfEndOmok.winnerUserId)
}
inline std::string* NtfEndOmok::mutable_winneruserid() {
  std::string* _s = _internal_mutable_winneruserid();
  // @@protoc_insertion_point(field_mutable:OmokPacket.NtfEndOmok.winnerUserId)
  return _s;
}
inline const std::string& NtfEndOmok::_internal_winneruserid() const {
  return _impl_.winneruserid_.Get();
}
inline void NtfEndOmok::_internal_set_winneruserid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.winneruserid_.Set(value, GetArenaForAllocation());
}
inline std::string* NtfEndOmok::_internal_mutable_winneruserid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.winneruserid_.Mutable(GetArenaForAllocation());
}
inline std::string* NtfEndOmok::release_winneruserid() {
  // @@protoc_insertion_point(field_release:OmokPacket.NtfEndOmok.winnerUserId)
  if (!_internal_has_winneruserid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.winneruserid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.winneruserid_.IsDefault()) {
    _impl_.winneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NtfEndOmok::set_allocated_winneruserid(std::string* winneruserid) {
  if (winneruserid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.winneruserid_.SetAllocated(winneruserid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.winneruserid_.IsDefault()) {
    _impl_.winneruserid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OmokPacket.NtfEndOmok.winnerUserId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace OmokPacket

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_OmokPacket_2eproto
